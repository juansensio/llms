
Pytorch 2.0
Pytorch 2.0 ya est치 aqu칤 游꿀游꿀游꿀 Tras varios meses en fase beta, la segunda versi칩n de nuestro framework favorito de deep learning ya est치 disponible. Si ya sabes trabajar con Pytorch, este post te servir치 para refrescar algunos conocimientos b치sicos a la vez que aprender치s sobre las novedades de Pytorch 2.0. Por otro lado, si no sabes nada de Pytorch, este post te servir치 como introducci칩n para aprender a usarlo desde cero.

En mi canal de Yotube tengo una lista de reproducci칩n con todos los v칤deos que he grabado sobre Pytorch. Te recomiendo que le eches un vistazo si quieres aprender m치s sobre este framework.

쯈u칠 es Pytorch?
Pytorch es un framework de redes neuronales, un conjunto de librer칤as y herramientas que nos hacen la vida m치s f치cil a la hora de dise침ar, entrenar y poner en producci칩n nuestros modelos de Deep Learning. Una forma sencilla de entender qu칠 es Pytorch es la siguiente:

 Pytorch = Numpy + Autograd + GPU 


















































Quiz치s la caracter칤stica m치s relevante de Pytorch es su facilidad de uso. Esto es debido a que sigue una interfaz muy similar a la de NumPy, por lo que si est치s familiarizado con esta librer칤a no deber칤a costarte mucho usar Pytorch 游때.

Si no conces Numpy te recomiendo que le eches un vistazo a este post.

Sin embargo, la funcionalidad m치s importante que Pytorch ofrece es la conocidad como autograd, la cual nos proporciona la posibilidad de calcular derivadas de manera autom치tica con respecto a cualquier tensor. Esto le da a Pytorch un gran potencial para dise침ar redes neuronales complejas y entrenarlas utilizando algoritmos de descenso por gradiente sin tener que calcular todas estas derivadas manualmente. Para poder llevar a cabo estas operaciones, Pytorch va construyendo de manera din치mica un grafo computacional. Cada vez que aplicamos una operaci칩n sobre uno o varios tensores, 칠stos se a침aden al grafo computacional junto a la operaci칩n en concreto. De esta manera, si queremos calcular la derivada de cualquier valor con respecto a cualquier tensor, simplemente tenemos que aplicar el algoritmo de backpropagation (que no es m치s que la regla de la cadena de la derivada) en el grafo.
Para que todo esto funcione de manera eficiente, Pytorch nos d ala posibilidad de ejecutar nuestro c칩digp en GPUs. Esto es posible gracias a que Pytorch est치 construido sobre CUDA, una librer칤a de C++ que nos permite programar en GPU. Por lo tanto, si tienes una GPU disponible, Pytorch la utilizar치 sin pr치cticamente ning칰n cambio en tu c칩digo para acelerar los c치lculos. Si no tienes una GPU, puedes usar servicios como Google Colab o Kaggle para ejecutar tu c칩digo en la nube.
Instalaci칩n
El primer paso para empezar a trabajar con Pytorch es instalarlo. Para ello, puedes seguir las instrucciones que aparecen en la p치gina oficial. En mi caso, voy a instalarlo usando conda en un ordenador con Linux y con soporte GPU:
conda install pytorch torchvision pytorch-cuda=11.7 -c pytorch -c nvidia


Si no sabes como instalar Python o Conda en tu sistema, puedes aprender a hacerlo en este post. Tambi칠n te recomiendo crear un entorno virtual para tu nueva instalaci칩n, as칤 evitar치s conflictos con otros proyectos que tengas en marcha.

En el momento de escribir este post el comando anterior instalar치 la versi칩n de Pytorch 2.0, en el momento en el que tu lo hagas instalar치 la versi칩n m치s reciente hasta la fecha. Para instalar versiones diferentes vista https://pytorch.org/get-started/previous-versions/.
Una vez instalado ya podr치s empezar a trabajar con Pytorch 游꿀游꿀游꿀
import torch

torch.__version__

'2.0.0.dev20230213+cu117'

Para saber si la GPU est치 disponible, puedes ejecutar
torch.cuda.is_available()

True

El siguiente comando te dar치 informaci칩n sobre tu sistema (si no funciona deber치s primero instalar los drivers de NVIDIA).
!nvidia-smi

Fri Mar 17 10:09:05 2023
+-----------------------------------------------------------------------------+
| NVIDIA-SMI 525.85.05    Driver Version: 525.85.05    CUDA Version: 12.0     |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|                               |                      |               MIG M. |
|===============================+======================+======================|
|   0  NVIDIA GeForce ...  Off  | 00000000:17:00.0 Off |                  N/A |
|  0%   55C    P0   106W / 350W |     29MiB / 24576MiB |      0%      Default |
|                               |                      |                  N/A |
+-------------------------------+----------------------+----------------------+
|   1  NVIDIA GeForce ...  Off  | 00000000:65:00.0 Off |                  N/A |
|  0%   56C    P8    29W / 350W |      8MiB / 24576MiB |      0%      Default |
|                               |                      |                  N/A |
+-------------------------------+----------------------+----------------------+

+-----------------------------------------------------------------------------+
| Processes:                                                                  |
|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |
|        ID   ID                                                   Usage      |
|=============================================================================|
|    0   N/A  N/A      1378      G   /usr/lib/xorg/Xorg                 16MiB |
|    0   N/A  N/A      1622      G   /usr/bin/gnome-shell                8MiB |
|    1   N/A  N/A      1378      G   /usr/lib/xorg/Xorg                  4MiB |
+-----------------------------------------------------------------------------+

Primeros pasos
Como comentabamos antes, Pytorch es muy similar a Numpy. Si bien el objeto principal en Numpy es el array, en Pytorch es el tensor. Un tensor es una matriz multidimensional con un tipo de datos concreto. Por ejemplo, podemos crear un tensor de 2x2 con ceros de la siguiente manera
x = torch.zeros(2, 2)
x

tensor([[0., 0.],
        [0., 0.]])

Puedes crear tensores con valores aleatorios
x = torch.randn(3)
x

tensor([-0.2063,  0.7455, -0.0131])

E incluso a partir de una lista de Python
x = torch.tensor([[1, 2, 3],[4, 5, 6]])
x

tensor([[1, 2, 3],
        [4, 5, 6]])

U otro array de Numpy
import numpy as np

a = np.array([[1, 2],[4, 5],[5, 6]])
x = torch.from_numpy(a)
x


tensor([[1, 2],
        [4, 5],
        [5, 6]])

Y como puedes esperar, pr치cticamente todos los conceptos que ya conocemos para trabajar con NumPy pueden aplicarse en Pytorch. Esto incluye operaciones aritm칠ticas, indexado y troceado, iteraci칩n, vectorizaci칩n y broadcasting.
# operaciones

x = torch.randn(3, 3)
y = torch.randn(3, 3)

x, y

(tensor([[ 1.6784,  1.7195, -0.5614],
         [ 1.0342, -0.5727, -0.4840],
         [ 0.4360,  1.4932,  0.3966]]),
 tensor([[ 1.0446,  0.3586, -0.9713],
         [-0.1943, -3.3726,  0.1241],
         [ 0.1605, -0.0124, -1.3009]]))

x + y

tensor([[ 2.7230,  2.0781, -1.5328],
        [ 0.8399, -3.9453, -0.3599],
        [ 0.5965,  1.4808, -0.9044]])

x - y

tensor([[ 0.6338,  1.3609,  0.4099],
        [ 1.2285,  2.7999, -0.6082],
        [ 0.2755,  1.5055,  1.6975]])

# indexado

# primera fila

x[0]

tensor([ 1.6784,  1.7195, -0.5614])

# primera fila, primera columna

x[0, 0]

tensor(1.6784)

# primera columna

x[0, :]

tensor([ 1.6784,  1.7195, -0.5614])

# troceado

x[:-1, 1:]

tensor([[ 1.7195, -0.5614],
        [-0.5727, -0.4840]])

Una funcionalidad importante del objeto tensor que utilizaremos muy a menudo es cambiar su forma. Esto lo conseguimos con la funci칩n view.
x.shape

torch.Size([3, 3])

# a침adimos una dimensi칩n extra

x.view(1, 3, 3).shape

torch.Size([1, 3, 3])

# estiramos en una sola dimensi칩n

x.view(9).shape

torch.Size([9])

# usamos -1 para asignar todos los valores restantes a una dimensi칩n

x.view(-1).shape

torch.Size([9])

Podemos transformar un tensor en un array con la funci칩n numpy.
x.numpy()

array([[ 1.6783874,  1.7194802, -0.5614443],
       [ 1.0342228, -0.5727211, -0.484026 ],
       [ 0.4360042,  1.4931623,  0.3965516]], dtype=float32)

Para aprender m치s sobre c칩mo funcionan estos tensores, puedes cosultar la documentaci칩n y este ejemplo
Autograd
Vamos a ver un ejemplo de autograd en acci칩n para el c치lculo de derivadas autom치ticas. Para ello, consideremos el siguiente grafo computacional sencillo:

Tenemos tres tensores, 
x






, 
y






 y 
z






, los cuales combinamos con diferente operacion para calcular 
g






. 쮺칩mo podemos encontrar la derivada de 
g






 con respecto a cada uno de los tensores a la entrada?. Para el caso de 
z






 esto es sencillo:

 \frac{dg}{dz} = p = x + y






























En el caso de 
x






 y 
y






 es un poco m치s complicado, ya que tenemos que aplicar la regla de la cadena de la derivada:

 \frac{dg}{dx} = \frac{dg}{dp} \frac{dp}{dx} = z 




















































 \frac{dg}{dy} = \frac{dg}{dp} \frac{dp}{dy} = z 



















































Si bien en este ejemplo sencillo lo hemos podido calcular a mano, imagina tener que hacer esto en redes neuronales con miles de millones de par치metros... imposible. Autograd nos permite calcular estas derivadas de manera autom치tica.
x = torch.tensor(1., requires_grad=True)
y = torch.tensor(2., requires_grad=True)
p = x + y

z = torch.tensor(3., requires_grad=True)
g = p * z

Para ello marcaremos los tensores de los cuales queremos calcular derivadas con la funci칩n requires_grad. Llamado a la funci칩n backwerd sobre el tensor de salida, autograd calcular치 las derivadas de manera autom치tica y las almacenar치 en el atributo grad de cada tensor.
g.backward()

z.grad # x + y

tensor(3.)

x.grad # z

tensor(3.)

y.grad # z

tensor(3.)

Como puedes ver, el grafo computacional es una herramienta extraordinaria para dise침ar redes neuronales de complejidad arbitraria. Con una simple funci칩n, gracias al algoritmo de backpropagation, podemos calcular todas las derivadas de manera sencilla (cada nodo que representa una operaci칩n solo necesita calcular su propia derivada de manera local) y optimizar el modelo con nuestro algoritmo de gradiente preferido.
A침adiendo autograd encima de NumPy, Pytorch nos ofrece todo lo que necesitamos para dise침ar y entrenar redes neuronales. Puedes aprender m치s sobre autograd aqu칤. Sin embargo, si queremos entrenar redes muy grandes o utilizar datasets muy grandes (o ambas), el proceso de entrenamiento ser치 muy lento. Es aqu칤 donde entra en juego el 칰ltimo elemento que hace de Pytorch lo que es.
GPU
La 칰ltima pieza que nos falta explorar es la posibilidad de ejecutar nuestro c칩digo en GPU. Para ello, solo tenemos que crear nuestros tensores en la GPU y ejecutar las operaciones de la misma manera. 춰Super sencillo!
x = torch.randn(3, 3, device="cuda")
y = torch.randn(3, 3, device="cuda")

x * y

tensor([[ 1.0285e-01, -1.0678e-01, -1.7388e-01],
        [-4.4772e-01,  2.6374e-01,  2.8962e-01],
        [ 3.0987e-01, -2.9449e-01, -4.0236e-04]], device='cuda:0')

Las siguientes son todas formas v치lidas de crear un tensor en la GPU
device = torch.device("cuda")           # device = "cuda" tambi칠n sirve

x = torch.randn(3, 3, device=device)    # crea el tensor en la GPU

x = torch.randn(3, 3)
x = x.to(device)                        # mueve el tensor a la GPU (menos eficiente)
x = x.cuda()                            # mueve el tensor a la GPU (menos eficiente)

device = "cuda:0"                       # selecciona la primera GPU, si hay m치s de una - "cuda:1", "cuda:2", etc.
x = torch.randn(3, 3, device=device)
x

tensor([[-0.4112, -0.0476, -0.4308],
        [-0.2315, -1.1937,  0.0723],
        [ 1.5994, -0.0311,  0.1895]], device='cuda:0')

Puedes copiar un tensor de la GPU a la CPU con la funci칩n cpu
device = torch.device("cpu")

x = x.cpu()
x = x.to("cpu")
x = x.to(device)

El siguiente ejemplo ilustra porque es importante ejecutar nuestro c칩digo en GPU. En este caso, vamos a calcular el tiempo que tarda en ejecutarse la multiplicaci칩n de dos matrices grandes.
# en cpu

x = torch.randn(10000,10000)
y = torch.randn(10000,10000)

%time z = x*y

CPU times: user 90.3 ms, sys: 165 ms, total: 256 ms
Wall time: 27.9 ms

# en gpu

x = torch.randn(10000,10000).cuda()
y = torch.randn(10000,10000).cuda()

%time z = x*y

CPU times: user 0 ns, sys: 17.6 ms, total: 17.6 ms
Wall time: 17.6 ms

Redes Neuronales
Pues ahora que ya conocemos los conceptos b치sicos de Pytorch vamos a ver como podemos dise침ar redes neuronales.
Modelos secuenciales
La forma m치s sencilla de definir una red neuronal en Pytorch es utilizando la clase Sequentail. Esta clase nos permite definir una secuencia de capas, que se aplicar치n de manera secuencial (las salidas de una capa ser치n la entrada de la siguiente). Vamos a definir un Perceptr칩n Multicapa (MLP).

Puedes aprender m치s sobre Perceptrones Multicapa en este post.

D_in, H, D_out = 784, 100, 10

model = torch.nn.Sequential(
    torch.nn.Linear(D_in, H),
    torch.nn.ReLU(),
    torch.nn.Linear(H, D_out),
)

model

Sequential(
  (0): Linear(in_features=784, out_features=100, bias=True)
  (1): ReLU()
  (2): Linear(in_features=100, out_features=10, bias=True)
)

El modelo anterior es un MLP con 784 entradas, una capa oculta de 100 neuronas y 10 salidas. Para ejectuar el modelo, podemos llamarlo como de si una funci칩n se tratase, pasando como argumento el tensor con los inputs.

La capa de tipo Linear espera un tensor de 2 dimensiones, en la cual la primera es la dimensi칩n del batch que puedes ser arbitraria y la segunda tiene que coincidir con el n칰mero de neuronas especificado, en nuestro ejemplo 784 en la primera capa y 100 en la segunda.

outputs = model(torch.randn(64, 784))
outputs.shape

torch.Size([64, 10])

De la misma manera que hemos visto antes con los tensores, podemos enviar nuestro modelo a la GPU para acelerar las operaciones internas.
model.cuda()
x = torch.randn(64, 784).cuda()

outputs = model(x)
outputs.shape, outputs.device

(torch.Size([64, 10]), device(type='cuda', index=0))

Modelos personalizados
Si bien los modelos secuenciales son 칰tiles para definir redes neuronales sencillas, en la pr치ctica casi siempre necesitaremos definir redes m치s complejas. Para ello, podemos definir nuestras propias clases que hereden de la clase Module de Pytorch. Esta clase nos permite definir modelos de manera m치s flexible, ya que nos permite dise침ar la l칩gica de ejecuci칩n del modelo a nuestro gusto.
class Model(torch.nn.Module):

    # constructor
    def __init__(self, D_in=784, H=100, D_out=10):

        # llamamos al constructor de la clase madre
        super(Model, self).__init__()

        # definimos nuestras capas
        self.fc1 = torch.nn.Linear(D_in, H)
        self.relu = torch.nn.ReLU()
        self.fc2 = torch.nn.Linear(H, D_out)

    # l칩gica para calcular las salidas de la red
    def forward(self, x):
        x = self.fc1(x)
        x = self.relu(x)
        x = self.fc2(x)
        return x

En primer lugar, necesitamos definir una nueva clase que herede de la clase torch.nn.Module. Esta clase madre aportar치 toda la funcionalidad esencial que necesita una red neuronal (soporte GPU, iterar por sus par치meteros, etc). Luego, en esta clase necesitamos definir m칤nimos dos funciones:

init: en el constructor llamaremos al constructor de la clase madre y despu칠s definiremos todas las capas que querramos usar en la red.
forward: en esta funci칩n definimos toda la l칩gica que aplicaremos desde que recibimos los inputs hasta que devolvemos los outputs.

En el ejemplo anterior simplemente hemos replicado la misma red (puedes conseguir el mismo efecto usando la clase Sequential).
model = Model(784, 100, 10)
outputs = model(torch.randn(64, 784))
outputs.shape

torch.Size([64, 10])

Compilando modelos
Una de las novedades que Pytorch 2.0 introduce es la posibilidad de compilar el modelo. Esto le permite analizar nuestro modelo para su optimizaci칩n, consiguiendo as칤 un mejor rendimiento durante el entrenamiento.
model_compiled = torch.compile(model)

Puedes aprender m치s sobre esta funcionalidad aqu칤.
Datasets
A la hora de entrenar una red neuronal, necesitamos un conjunto de datos sobre el que entrenar. Para ello, Pytorch nos ofrece funcionalidad para su creaci칩n e iteraci칩n de manera optimizada. Vamos a ver un ejemplo usando el conjunto de datos MNIST, que podemos descargar usando Scikit-Learn.
from sklearn.datasets import fetch_openml
import numpy as np


mnist = fetch_openml('mnist_784', version=1)
X, Y = mnist["data"].values.astype(float).reshape(-1, 28, 28) / 255., mnist["target"].values.astype(int)
np.savez_compressed("mnist.npz", X=X, y=Y)

# la descarga puede tardar un rato, as칤 que te recomiendo comentar las l칤neas anteriores despu칠s
# de ejecutarlas la primera vez y descomentar las siguientes para cargar los datos desde el disco

# X, Y = np.load("mnist.npz")["X"], np.load("mnist.npz")["y"]

X.shape, Y.shape

((70000, 28, 28), (70000,))

import matplotlib as mpl
import matplotlib.pyplot as plt
import random

r, c = 3, 5
fig = plt.figure(figsize=(2*c, 2*r))
for _r in range(r):
    for _c in range(c):
        plt.subplot(r, c, _r*c + _c + 1)
        ix = random.randint(0, len(X)-1)
        plt.imshow(X[ix], cmap='gray')
        plt.axis("off")
        plt.title(y[ix])
plt.tight_layout()
plt.show()


Este dataset consiste en im치genes de d칤gitos manuscritos (del 0 al 9) con su correspondiente etiqueta, un dataset muy 칰til para aprender a entrenar redes neuronales, en concreto para clasificaci칩n de im치genes.
El DataLoader
El DataLoader es un objeto que nos permite iterar nuestro dataset en batches de manera eficiente. Podemos pasarle como argumento cualquier iterador, desde una lista de Python hasta un array de NumPy o un tensor de Pytorch.
dataloader = torch.utils.data.DataLoader(X, batch_size=100)

for batch in dataloader:
    print(batch.shape)
    break

torch.Size([100, 28, 28])

Tiene varias opciones interesantes que nos permitir치n mejorar la eficiencia de nuestro entrenamiento.
dataloader = torch.utils.data.DataLoader(
    X,                      # datos
    batch_size=100,         # tama침o del batch, n칰mero de im치genes por iteraci칩n
    shuffle=True,           # barajamos los datos antes de cada epoch
    num_workers=4,          # n칰mero de procesos que se lanzan para cargar los datos (n칰mero de cores de la CPU para carga en paralelo)
    pin_memory=True,        # si tenemos una GPU, los datos se cargan en la memoria de la GPU
    collate_fn=None,        # funci칩n para combinar los datos de cada batch
)

El Dataset
Si bien el dataloader es capaz de trabajar con cualquier iterador, Pytorch nos ofrece una clase base para crear nuestros propios datasets
class Dataset(torch.utils.data.Dataset):
    # constructor
    def __init__(self, X, Y):
        self.X = torch.tensor(X).float()
        self.Y = torch.tensor(Y).long()
    # cantidad de muestras en el dataset
    def __len__(self):
        return len(self.X)
    # devolvemos el elemento `ix` del dataset
    def __getitem__(self, ix):
        return self.X[ix], self.Y[ix]
    # opcionalmente, podemos definir una funci칩n para generar un batch
    def collate_fn(self, batch):
        x, y = [], []
        for _x, _y in batch:
            x.append(_x)
            y.append(_y)
        return torch.stack(x).view(len(batch), -1), torch.stack(y) # estiramos las im치genes en una dimensi칩n

Para ello crearemos una nueva clase que hereda de torch.utils.data.Dataset, en la cual definiremos estas tres funciones:

__init__: el constructor
__len__: devuelve el n칰mero de muestras en el dataset
__getitem__: devuelve una muestra en concreto del dataset

Cada vez que nuestro dataloader necesite una nueva muestra, llamar치 a la funci칩n __getitem__ pas치ndole el 칤ndice de la muestra que necesita. Aqu칤 podremos definir cualquier l칩gica de carga y procesado de datos (por ejemplo, leer im치genes y aplicar transformaciones).
dataset = Dataset(X, Y)
dataloader = torch.utils.data.DataLoader(dataset, batch_size=100)

for batch in dataloader:
    x, y = batch
    print(x.shape, y.shape)
    break

torch.Size([100, 28, 28]) torch.Size([100])

dataloader = torch.utils.data.DataLoader(dataset, batch_size=100, collate_fn=dataset.collate_fn)

for batch in dataloader:
    x, y = batch
    print(x.shape, y.shape)
    break

torch.Size([100, 784]) torch.Size([100])

Entrenamiento
Ha llegado el momento de ver c칩mo podemos entrenar nuestro modelo con el dataset que hemos creado. Empezaremos con un ejemplo m칤nimo, en el que entrenaremos nuestro MLP con el dataset MNIST.

Adem치s del modelo y los datos necesitaremos dos elementos m치s para el enterenamiento:

Una funci칩n de p칠rdida (medir치 el error del modelo)
Un optimizador (se encargar치 de actualizar los par치metros del modelo para minimizar la funci칩n de p칠rdida)

En ambos casos, Pytorch nos ofrece una amplia gama de opciones, que podemos consultar en la documentaci칩n.

Puedes aprender m치s sobre estos conceptos aqu칤.

# instanciamos nuestro dataset
dataset = Dataset(X, Y)
dataloader = torch.utils.data.DataLoader(dataset, batch_size=100, collate_fn=dataset.collate_fn)
# instanciamos nuestro modelo
model = Model(784, 100, 10)
# definimos la funci칩n de p칠rdida y el optimizador
criterion = torch.nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(model.parameters())
# bucle de entrenamiento
epochs = 5
for e in range(1, epochs+1):
    print(f"epoch: {e}/{epochs}")
    for batch_ix, (x, y) in enumerate(dataloader):
        optimizer.zero_grad()           # reseteamos los gradientes
        outputs = model(x)              # calculamos las salidas
        loss = criterion(outputs, y)    # calculamos la p칠rdida
        loss.backward()                 # calculamos los gradientes
        optimizer.step()                # actualizamos los par치metros
        if batch_ix % 100 == 0:
            loss, current = loss.item(), (batch_ix + 1) * len(x)
            print(f"loss: {loss:.4f} [{current:>5d}/{len(dataset):>5d}]")


epoch: 1/5
loss: 2.3083 [  100/70000]
loss: 0.4708 [10100/70000]
loss: 0.4804 [20100/70000]
loss: 0.3436 [30100/70000]
loss: 0.2486 [40100/70000]
loss: 0.2684 [50100/70000]
loss: 0.1554 [60100/70000]
epoch: 2/5
loss: 0.1684 [  100/70000]
loss: 0.2374 [10100/70000]
loss: 0.2315 [20100/70000]
loss: 0.2300 [30100/70000]
loss: 0.1569 [40100/70000]
loss: 0.1538 [50100/70000]
loss: 0.0832 [60100/70000]
epoch: 3/5
loss: 0.1205 [  100/70000]
loss: 0.1479 [10100/70000]
loss: 0.1593 [20100/70000]
loss: 0.2072 [30100/70000]
loss: 0.1202 [40100/70000]
loss: 0.1048 [50100/70000]
loss: 0.0513 [60100/70000]
epoch: 4/5
loss: 0.1045 [  100/70000]
loss: 0.1018 [10100/70000]
loss: 0.1186 [20100/70000]
loss: 0.1899 [30100/70000]
loss: 0.1018 [40100/70000]
loss: 0.0798 [50100/70000]
loss: 0.0350 [60100/70000]
epoch: 5/5
loss: 0.0954 [  100/70000]
loss: 0.0766 [10100/70000]
loss: 0.0974 [20100/70000]
loss: 0.1619 [30100/70000]
loss: 0.0900 [40100/70000]
loss: 0.0665 [50100/70000]
loss: 0.0270 [60100/70000]

Si todo va seg칰n lo planeado, deber칤amos ver como la funci칩n de p칠rdida va disminuyendo a medida que el modelo va aprendiendo. En un ejemplo real, sin embargo, haremos un entrenamiento m치s sofisticado, en el que dividiremos nuestro dataset en dos partes: una para entrenar y otra para validar el modelo; y tambi칠n trackearemos diversas m칠tricas para evaluar el rendimiento del modelo (aunque en un caso real deber칤a usar algun sistema de trackeado como Weights and Biases o MLFLow).

Puedes aprender m치s sobre este tema aqu칤.

# instanciamos nuestro dataset
dataset = {
    "train": Dataset(X[:60000], Y[:60000]),
    "val": Dataset(X[60000:], Y[60000:])
}
dataloader = {
    'train': torch.utils.data.DataLoader(dataset['train'], batch_size=100, collate_fn=dataset['train'].collate_fn),
    'val': torch.utils.data.DataLoader(dataset['val'], batch_size=100, collate_fn=dataset['val'].collate_fn)
}
# instanciamos nuestro modelo
model = Model(784, 100, 10)
# definimos la funci칩n de p칠rdida y el optimizador
criterion = torch.nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(model.parameters())
# bucle de entrenamiento
epochs = 5
for e in range(1, epochs+1):
    print(f"epoch: {e}/{epochs}")
    # entrenamiento
    model.train()
    for batch_ix, (x, y) in enumerate(dataloader['train']):
        optimizer.zero_grad()
        outputs = model(x)
        loss = criterion(outputs, y)
        loss.backward()
        optimizer.step()
        if batch_ix % 100 == 0:
            loss, current = loss.item(), (batch_ix + 1) * len(x)
            print(f"loss: {loss:.4f} [{current:>5d}/{len(dataset):>5d}]")
    # validaci칩n
    model.eval()
    val_loss, val_acc = [], []
    with torch.no_grad():
        for batch_ix, (x, y) in enumerate(dataloader['val']):
            outputs = model(x)
            loss = criterion(outputs, y)
            val_loss.append(loss.item())
            val_acc.append((outputs.argmax(1) == y).float().mean().item())
    print(f"val_loss: {np.mean(val_loss):.4f} val_acc: {np.mean(val_acc):.4f}")


epoch: 1/5
loss: 2.3281 [  100/60000]
loss: 0.4712 [10100/60000]
loss: 0.4959 [20100/60000]
loss: 0.3392 [30100/60000]
loss: 0.2554 [40100/60000]
loss: 0.2822 [50100/60000]
val_loss: 0.2487 val_acc: 0.9275
epoch: 2/5
loss: 0.2017 [  100/60000]
loss: 0.2150 [10100/60000]
loss: 0.2756 [20100/60000]
loss: 0.2219 [30100/60000]
loss: 0.1550 [40100/60000]
loss: 0.1612 [50100/60000]
val_loss: 0.1753 val_acc: 0.9474
epoch: 3/5
loss: 0.1222 [  100/60000]
loss: 0.1526 [10100/60000]
loss: 0.1959 [20100/60000]
loss: 0.1804 [30100/60000]
loss: 0.1038 [40100/60000]
loss: 0.1215 [50100/60000]
val_loss: 0.1395 val_acc: 0.9580
epoch: 4/5
loss: 0.0852 [  100/60000]
loss: 0.1147 [10100/60000]
loss: 0.1590 [20100/60000]
loss: 0.1604 [30100/60000]
loss: 0.0801 [40100/60000]
loss: 0.1088 [50100/60000]
val_loss: 0.1198 val_acc: 0.9637
epoch: 5/5
loss: 0.0675 [  100/60000]
loss: 0.0874 [10100/60000]
loss: 0.1338 [20100/60000]
loss: 0.1493 [30100/60000]
loss: 0.0692 [40100/60000]
loss: 0.1007 [50100/60000]
val_loss: 0.1090 val_acc: 0.9664

Como puedes observar podemos poner el modelo en modo entrenamiento o evaluaci칩n con las funciones train y eval. Esto es importante ya que algunas capas (como Dropout o BatchNorm) tienen comportamientos diferentes en cada modo. Adem치s, durante la validaci칩n, usamos el contexto torch.no_grad para que no se calcule el gradiente, ya que no lo necesitamos (esto har치 que el entrenamiento sea m치s r치pido).
Consejos para mejores prestaciones
En este ejemplo sencillo todo va r치pido, pero en casos reales puede que tengamos que esperar mucho tiempo a que el modelo se entrene. Para ello, podemos hacer algunas cosas para mejorar la velocidad de entrenamiento
dataset = {
    "train": Dataset(X[:60000], Y[:60000]), # 60.000 im치genes para entrenamiento
    "val": Dataset(X[60000:], Y[60000:])    # 10.000 im치genes para validaci칩n
}
# aumentamos el tama침o del batch para aprovechar la GPU, carga en paralelo y movemos los datos a la GPU
dataloader = {
    'train': torch.utils.data.DataLoader(dataset['train'], batch_size=1000, shuffle=True, num_workers=4, pin_memory=True, collate_fn=dataset['train'].collate_fn),
    'val': torch.utils.data.DataLoader(dataset['val'], batch_size=1000, num_workers=4, pin_memory=True, collate_fn=dataset['val'].collate_fn)
}
model = Model(784, 100, 10)
# compilamos el modelo
# model = torch.compile(model)
# torch.backends.cuda.matmul.allow_tf32 = True # allow tf32 on matmul
# torch.backends.cudnn.allow_tf32 = True # allow tf32 on cudnn
# movemos el modelo a la GPU
model.cuda()
criterion = torch.nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(model.parameters())
epochs = 5
for e in range(1, epochs+1):
    print(f"epoch: {e}/{epochs}")
    # entrenamiento
    model.train()
    for batch_ix, (x, y) in enumerate(dataloader['train']):
        x, y = x.cuda(), y.cuda()                                                   # movemos los datos a la GPU
        optimizer.zero_grad()
        with torch.autocast(device_type='cuda', dtype=torch.bfloat16):              # automatic mixed precision
            outputs = model(x)
            loss = criterion(outputs, y)
        loss.backward()
        optimizer.step()
        if batch_ix % 10 == 0:
            loss, current = loss.item(), (batch_ix + 1) * len(x)
            print(f"loss: {loss:.4f} [{current:>5d}/{len(dataset['train']):>5d}]")
    # validaci칩n
    model.eval()
    val_loss, val_acc = [], []
    with torch.no_grad():
        for batch_ix, (x, y) in enumerate(dataloader['val']):
            x, y = x.cuda(), y.cuda()                                               # movemos los datos a la GPU
            with torch.autocast(device_type='cuda', dtype=torch.bfloat16):          # automatic mixed precision
                outputs = model(x)
                loss = criterion(outputs, y)
            val_loss.append(loss.item())
            val_acc.append((outputs.argmax(1) == y).float().mean().item())
    print(f"val_loss: {np.mean(val_loss):.4f} val_acc: {np.mean(val_acc):.4f}")

epoch: 1/5
loss: 2.3098 [ 1000/60000]
loss: 1.7387 [11000/60000]
loss: 1.1731 [21000/60000]
loss: 0.8057 [31000/60000]
loss: 0.6480 [41000/60000]
loss: 0.4715 [51000/60000]
val_loss: 0.4343 val_acc: 0.8917
epoch: 2/5
loss: 0.4613 [ 1000/60000]
loss: 0.3864 [11000/60000]
loss: 0.3995 [21000/60000]
loss: 0.3641 [31000/60000]
loss: 0.3603 [41000/60000]
loss: 0.3143 [51000/60000]
val_loss: 0.3096 val_acc: 0.9154
epoch: 3/5
loss: 0.3157 [ 1000/60000]
loss: 0.2750 [11000/60000]
loss: 0.3310 [21000/60000]
loss: 0.3152 [31000/60000]
loss: 0.3120 [41000/60000]
loss: 0.2451 [51000/60000]
val_loss: 0.2718 val_acc: 0.9231
epoch: 4/5
loss: 0.2578 [ 1000/60000]
loss: 0.2539 [11000/60000]
loss: 0.2705 [21000/60000]
loss: 0.2583 [31000/60000]
loss: 0.2628 [41000/60000]
loss: 0.2335 [51000/60000]
val_loss: 0.2404 val_acc: 0.9321
epoch: 5/5
loss: 0.2486 [ 1000/60000]
loss: 0.2486 [11000/60000]
loss: 0.2587 [21000/60000]
loss: 0.2530 [31000/60000]
loss: 0.2613 [41000/60000]
loss: 0.2532 [51000/60000]
val_loss: 0.2203 val_acc: 0.9358

En el caso de entrenar modelos muy grandes, es posible hacerlo en varias GPUs para acelerar el entrenamiento. Puedes aprender m치s sobre este tema aqu칤.
Por 칰ltimo, te dejo tambi칠n mi receta de entrenamiento de redes neuronales, que puedes seguir a la hora de dise침ar y entrenar tus modelos.
Exportando modelos
Una vez entrenado tu modelo es posible que quieras exportarlo para usarlo en otro proyecto o incluso en producci칩n. Para ello, Pytorch nos ofrece diferents opciones para exportar nuestro modelo. La forma m치s sencilla es usar la funci칩n torch.save, que nos permite guardar el modelo en un fichero.
torch.save(model, 'model.pth')

Una vez guardado lo podr치s leer desde cualquier otro proyecto usando la funci칩n torch.load.
loaded = torch.load('model.pth')
loaded

Model(
  (fc1): Linear(in_features=784, out_features=100, bias=True)
  (relu): ReLU()
  (fc2): Linear(in_features=100, out_features=10, bias=True)
)

Una alternativa m치s eficiente y flexible consiste en exporar el state_dict
torch.save(model.state_dict(), 'model.ckpt')

model = Model(784, 100, 10)
model.load_state_dict(torch.load('model.ckpt'))
model

Model(
  (fc1): Linear(in_features=784, out_features=100, bias=True)
  (relu): ReLU()
  (fc2): Linear(in_features=100, out_features=10, bias=True)
)

Adem치s del modelo podemos guardar el state_dict del optimizador para poder continuar el entrenamiento en otro momento, por lo que es muy 칰til para guardar checkpoints.
En ambos casos vas a necesitar el mismo c칩digo usado a la hora de exportar el modelo para poder cargarlo. Esto puede ser un inconveniente en muchos casos, por lo que una buena alternativa es usar torch.script para serializar el modelo.
model_scripted = torch.jit.script(model)
model_scripted.save('model_scripted.pt')

model = torch.jit.load('model_scripted.pt')
model

RecursiveScriptModule(
  original_name=Model
  (fc1): RecursiveScriptModule(original_name=Linear)
  (relu): RecursiveScriptModule(original_name=ReLU)
  (fc2): RecursiveScriptModule(original_name=Linear)
)

Esta aproximaci칩n permite desacoplar el c칩digo de los pesos del modelo, sin embargo vamos a seguir necesitando Pytorch para poder cargar el modelo (lo cual no siempre ser치 posible en funci칩n del entorno de producci칩n del modelo). Para ello podemos usar ONNX para exportar el modelo a un formato est치ndar que puede ser usado por cualquier framework.
torch.onnx.export(
    model.cpu(),
    torch.randn(10, 784),
    'model.onnx',
    opset_version=11,
    input_names=['input'],
    output_names=['output'],
    dynamic_axes={'input': {0: 'batch_size'}, 'output': {0: 'batch_size'}
})

======= Diagnostic Run torch.onnx.export version 2.0.0.dev20230213+cu117 =======
verbose: False, log level: Level.ERROR
======================= 0 NONE 0 NOTE 0 WARNING 0 ERROR ========================

import onnx

onnx_model = onnx.load('model.onnx')
onnx.checker.check_model(onnx_model)

En Python podemos usar la librer칤a onnxruntime para cargar el modelo y usarlo en producci칩n, en los que no es necesario que Pytorch est칠 instalado (funciona directamente con NumPy).
import onnxruntime as ort

ort_session = ort.InferenceSession('model.onnx')
ort_inputs = {ort_session.get_inputs()[0].name: torch.randn(16, 784).numpy()}
ort_outs = ort_session.run(None, ort_inputs)
ort_outs[0].shape

(16, 10)

Ecosistema
Pytorch es un proyecto muy activo, con una gran comunidad de desarrolladores que contribuyen a su mejora. Adem치s, cuenta con una gran cantidad de librer칤as que nos permiten extender sus funcionalidades. Algunos ejemplos son:

Torchvision: librer칤a de visi칩n por computador para Pytorch, puedes aprender m치s sobre ella aqu칤.
Torchtext: librer칤a de procesamiento de lenguaje natural para Pytorch, puedes aprender m치s sobre ella aqu칤.
Huggingface: gran ecosistema conocido por su librer칤a de transformers pero que poco a poco a evolucionado incluyendo muchas otras funcionalidades, puedes aprender m치s sobre ella aqu칤.
Torhcmetrics: librer칤a de m칠tricas para Pytorch.

De entre todas ellas, destacar칤a Pytorch Lightning, una librer칤a que nos hace la vida m치s f치cil a la hora de entrenar modelos y que veremos en detalle en el siguiente post ya que tambi칠n acaba de lanzar su versi칩n 2.0.
