
Sensio CoPilot
En este post vamos a entrenar una red neuronal para generaci칩n de c칩digo similar al funcionamiento de Github Copilot. Llevo usando Copilot unos meses y la verdad que puedo decir que es una herramienta incre칤ble, que ha aumentado considerablemente mi productividad como programador. Hace unos d칤as le칤 este hilo en Twitter y cre칤 que ser칤a interesante intentar replicar un sistema como Copilot desde cero. As칤 que sin m치s dilaci칩n, 춰vamos a ello!
Github Copilot utiliza el modelo conocido como Codex, desarrollado por OpenAI. Este modelo est치 basado en la arquitectura GPT (de lo que hablaremos m치s adelante) y tuneado con c칩digo p칰blico extra칤do de Github. Esto significa que el modelo fue pre-entrenado de manera no supervisada con mucho texto y luego se hizo fine tuning con el c칩digo extra칤do de Github para la tarea de generaci칩n de texto (nuevo c칩digo autocompletado). En contraste, nosotros entrenaremos un modelo desde cero para la tarea de generaci칩n de texto con un dataset preparado para ello a modo de demostraci칩n.
El Dataset
El dataset usado por OpenAI para entrenar Codex fue extra칤do de 54 millones de reposiotrios p칰blicos de Github, conteniendo 179 GB de archivos Python de menos de 1 MB. Tras varias etapas de procesado, el dataset final ocup칩 159 GB. Como no tenemos acceso a este dataset, usaremos CodeParrot, un dataset elaborado por HuggingFace para la tarea de generaci칩n de c칩digo.

Recuerda que OpenAI al final tiene que ganar dinero de alguna manera, y 칠sta es cobrando por el uso de sus modelos a trav칠s de la API. Siendo el modelo p칰blico, su 칰nica ventaja competitiva reside en los datos usados durante el entrenamiento. Esto es una tendencia clara en el mundo del Software 2.0, d칩nde el valor real est치 en los datos y no en el c칩digo (aunque como dir칤a Andrej Karpathy en el Software 2.0 los datos SON el c칩digo y el modelo no es m치s que el binario resultante de la compilaci칩n del mismo, lo que llamamos el proceso de entrenamiento).

El dataset ocupa unos 50 GB, aproximadamente una tercera parte del dataset usado originalmente por OpenAI. 춰Nada mal! Puedes descargarlo utilizando los siguientes comandos:
git clone https://huggingface.co/datasets/lvwerra/codeparrot-clean-train
git clone https://huggingface.co/datasets/lvwerra/codeparrot-clean-valid


Para poder descargarlos necesitar치s instalar Git LFS.

from pathlib import Path
from glob import glob

path = Path('data/codeparrot-clean-train')

files = glob(str(path) + '/*.json.gz')
len(files), files[:3]

(52,
 ['data/codeparrot-clean-train/file-000000000007.json.gz',
  'data/codeparrot-clean-train/file-000000000053.json.gz',
  'data/codeparrot-clean-train/file-000000000026.json.gz'])

import pandas as pd

file = pd.read_json(files[2], lines=True)
file







repo_name
path
copies
size
content
license
hash
line_mean
line_max
alpha_frac
autogenerated




0
jalavik/inspire-next
setup.py
1
4558
# -*- coding: utf-8 -*-\n#\n# This file is par...
gpl-2.0
-4849180608980663294
27.848101
77
0.615840
False


1
dlzhangxg/cloud-ml-sdk
cloud_ml_samples/keras/mnist/trainer/task.py
1
2967
# Copyright 2017 Xiaomi, Inc.\n#\n# Licensed u...
apache-2.0
-1822461891537938192
30.231579
74
0.649815
False


2
openstack/heat
heat/engine/support.py
1
2683
#\n#    Licensed under the Apache License, Ver...
apache-2.0
-1815098437948811103
36.788732
78
0.622438
False


3
imapp-pl/golem
tests/golem/network/test_golem_protocol.py
1
1444
import unittest\nfrom devp2p.service import Wi...
gpl-3.0
-5671972220290336808
37.000000
77
0.654432
False


4
willimoa/pydal
pydal/dialects/mongo.py
1
22083
import re\nfrom .._compat import PY2, basestri...
bsd-3-clause
7148857323817256703
34.389423
93
0.518951
False


...
...
...
...
...
...
...
...
...
...
...
...


99995
georgestarcher/TA-SyncKVStore
bin/ta_synckvstore/cloudconnectlib/core/ext.py
1
10300
import calendar\nimport json\nimport re\nimpor...
mit
-2116068727318744484
29.654762
80
0.593495
False


99996
nabucosound/django-propaganda
propaganda/migrations/0001_initial.py
1
2828
# -*- coding: utf-8 -*-\nfrom __future__ impor...
bsd-3-clause
2285667758777388556
38.830986
114
0.541372
False


99997
znuxor/aoc2016
4.py
1
41871
#!/usr/bin/python3\nimport operator\n\n# room ...
bsd-3-clause
-2104829268388077325
40.662687
118
0.834659
False


99998
sharadagarwal/autorest
AutoRest/Generators/Python/Python.Tests/Expect...
1
5365
# coding=utf-8\n# ----------------------------...
mit
-2646046330546511516
35.250000
110
0.630009
False


99999
DeathSurvivorDE/dhbw_schreitbagger
Schreitbagger/Bagger_GUI_v0-0-0-3_st.py
1
8009
\n'''\nBagger_GUI v0.0.0.1\n\nGrafische Benutz...
gpl-3.0
54990144954214641
54.020690
212
0.507145
False



100000 rows 칑 11 columns

file.content[10]

'#!/usr/bin/env python\n\n# Copyright (C) 2014 Aldebaran Robotics\n#\n# Licensed under the Apache License, Version 2.0 (the "License");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an "AS IS" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n#import ROS dependencies\nimport rospy\n\n#import NAO dependencies\nfrom naoqi_driver.naoqi_node import NaoqiNode\nfrom geometry_msgs.msg import PoseStamped\nfrom geometry_msgs.msg import Pose\nimport almath\nimport tf\nfrom tf.transformations import euler_from_quaternion\n\nclass MoveToListener(NaoqiNode):\n\n    def __init__(self):\n        NaoqiNode.__init__(self, \'naoqi_moveto_listener\')\n        self.connectNaoQi()\n        self.listener = tf.TransformListener()\n\n        self.subscriber = rospy.Subscriber("/move_base_simple/goal", PoseStamped, self.callback)\n\n    # (re-) connect to NaoQI:\n    def connectNaoQi(self):\n        rospy.loginfo("Connecting to NaoQi at %s:%d", self.pip, self.pport)\n\n        self.motionProxy = self.get_proxy("ALMotion")\n        if self.motionProxy is None:\n            exit(1)\n\n    def callback(self, poseStamped):\n        # reset timestamp because of bug: https://github.com/ros/geometry/issues/82\n        poseStamped.header.stamp = rospy.Time(0)\n        try:\n            robotToTarget1 = self.listener.transformPose("/base_footprint", poseStamped)\n        except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException) as e:\n            rospy.logerr("Error while transforming pose: %s", str(e))\n            return\n        quat = robotToTarget1.pose.orientation\n        (roll,pitch,yaw) = euler_from_quaternion((quat.x, quat.y, quat.z, quat.w))\n        self.motionProxy.moveTo(robotToTarget1.pose.position.x, robotToTarget1.pose.position.y, yaw)\n'

En posts anteriores en los que ya hemos hablado sobre aplicaciones de NLP vimos que a una red neuronal no podemos darle texto como entrada, sino n칰meros. El proceso de convertir las palabras de nuestro dataset en n칰meros se conoce como tokenizaci칩n. Una opci칩n ser칤a construir un vector tan largo como n칰mero de palabras diferentes haya en el dataset y asignar un valor de 1 a la posici칩n determinada por la palabra en concreto. Esta forma de tokenizaci칩n se conoce como one-hot-encoding y como puedes imaginar es muy ineficiente. Lo m치s com칰n consiste en convertir cada palabra en n칰mero entero y luego darle a la red como entrada la fila correspondiente en una matriz de embedding con dimensionalidad fijada por nosotros. Esto es mucho m치s eficiente, ya que el vector ser치 denso y tambi칠n permite establecer relaciones matem치ticas entre palabras muy 칰til para la red. Si bien puedes implementar tu propia l칩gica de tokenizaci칩n aqu칤 usaremos una ya dado por la librer칤a transformers, de esta manera nos evitaremos muchos dolores de cabeza como diferenciar entre palabras en may칰scula o min칰scula, tratar los s칤mbolos, etc. En este caso usaremos el tokenizador usado por el modelo BERT.
from transformers import BertTokenizer

tokenizer = BertTokenizer.from_pretrained('bert-base-uncased')

tokens = tokenizer.tokenize('def ADD_numbers(a, b):\n return ')

tokens

['def', 'add', '_', 'numbers', '(', 'a', ',', 'b', ')', ':', 'return']

indexes = tokenizer.convert_tokens_to_ids(tokens)

indexes

[13366, 5587, 1035, 3616, 1006, 1037, 1010, 1038, 1007, 1024, 2709]

Es importante tener en cuenta que el lenguaje usado en programaci칩n es mucho m치s restringido que el lenguaje natural, por lo que usar un tokenizer custom es probablemente una muy buena idea, reduciendo considerablemente el n칰mero de tokens necesarios y aumentando as칤 la eficiencia de nuestro modelo.

Puedes aprender m치s sobre tokinizers aqu칤. Como ver치s existen muchas aproximaciones al problema, desde soluciones tan simples como contar el n칰mero de ocurrencias de cada palabra y usar su posici칩n en la lista ordenada de todas las ocurrencias como token hasta reglas m치s complicadas. A medida que los transformers se hacen m치s grandes y potentes, pudiendo procesar longitdes m치s largas a la entrada, la 칰ltima moda es usar directamente la representaci칩n ASCII de los caracteres, evitando cualquier tipo de tokenizaci칩n 游땍 (de lo cual soy muy fan).

x = 'Hola'

y = [ord(c) for c in x]
y

[72, 111, 108, 97]

El Modelo
El modelo usado por OpenAI, Codex, est치 basado en la arquitectura GPT y contiene 12 billones de par치metros. Esto est치 un poco fuera de nuestra alcance (de momento 游땧) as칤 que usaremos la implementaci칩n de Karpathy, minGPT, que nos permite entrenar peque침os transformers basados en la arquitectura GPT.
git clone https://github.com/karpathy/minGPT.git
Puedes jugar con el tama침os de la entrada (el n칰mero de token a usar), el n칰mero de capas, cabezas por capa y dimensi칩n interna de las capas de atenci칩n. Nuestro modelo recibir치 a la entrada un batch de trozos de c칩digo y nos dar치 a la salida un distribuci칩n de probabilidad sobre el vocabulario, d칩nde el valor m치s alto corresponder치 a aquella palabra que el modelo cree que ir치 a continuaci칩n.
from minGPT.mingpt.model import GPT, GPTConfig

mconf = GPTConfig(tokenizer.vocab_size, block_size=512, n_layer=8, n_head=8, n_embd=512)
model = GPT(mconf)

model

GPT(
  (tok_emb): Embedding(30522, 512)
  (drop): Dropout(p=0.1, inplace=False)
  (blocks): Sequential(
    (0): Block(
      (ln1): LayerNorm((512,), eps=1e-05, elementwise_affine=True)
      (ln2): LayerNorm((512,), eps=1e-05, elementwise_affine=True)
      (attn): CausalSelfAttention(
        (key): Linear(in_features=512, out_features=512, bias=True)
        (query): Linear(in_features=512, out_features=512, bias=True)
        (value): Linear(in_features=512, out_features=512, bias=True)
        (attn_drop): Dropout(p=0.1, inplace=False)
        (resid_drop): Dropout(p=0.1, inplace=False)
        (proj): Linear(in_features=512, out_features=512, bias=True)
      )
      (mlp): Sequential(
        (0): Linear(in_features=512, out_features=2048, bias=True)
        (1): GELU()
        (2): Linear(in_features=2048, out_features=512, bias=True)
        (3): Dropout(p=0.1, inplace=False)
      )
    )
    (1): Block(
      (ln1): LayerNorm((512,), eps=1e-05, elementwise_affine=True)
      (ln2): LayerNorm((512,), eps=1e-05, elementwise_affine=True)
      (attn): CausalSelfAttention(
        (key): Linear(in_features=512, out_features=512, bias=True)
        (query): Linear(in_features=512, out_features=512, bias=True)
        (value): Linear(in_features=512, out_features=512, bias=True)
        (attn_drop): Dropout(p=0.1, inplace=False)
        (resid_drop): Dropout(p=0.1, inplace=False)
        (proj): Linear(in_features=512, out_features=512, bias=True)
      )
      (mlp): Sequential(
        (0): Linear(in_features=512, out_features=2048, bias=True)
        (1): GELU()
        (2): Linear(in_features=2048, out_features=512, bias=True)
        (3): Dropout(p=0.1, inplace=False)
      )
    )
    (2): Block(
      (ln1): LayerNorm((512,), eps=1e-05, elementwise_affine=True)
      (ln2): LayerNorm((512,), eps=1e-05, elementwise_affine=True)
      (attn): CausalSelfAttention(
        (key): Linear(in_features=512, out_features=512, bias=True)
        (query): Linear(in_features=512, out_features=512, bias=True)
        (value): Linear(in_features=512, out_features=512, bias=True)
        (attn_drop): Dropout(p=0.1, inplace=False)
        (resid_drop): Dropout(p=0.1, inplace=False)
        (proj): Linear(in_features=512, out_features=512, bias=True)
      )
      (mlp): Sequential(
        (0): Linear(in_features=512, out_features=2048, bias=True)
        (1): GELU()
        (2): Linear(in_features=2048, out_features=512, bias=True)
        (3): Dropout(p=0.1, inplace=False)
      )
    )
    (3): Block(
      (ln1): LayerNorm((512,), eps=1e-05, elementwise_affine=True)
      (ln2): LayerNorm((512,), eps=1e-05, elementwise_affine=True)
      (attn): CausalSelfAttention(
        (key): Linear(in_features=512, out_features=512, bias=True)
        (query): Linear(in_features=512, out_features=512, bias=True)
        (value): Linear(in_features=512, out_features=512, bias=True)
        (attn_drop): Dropout(p=0.1, inplace=False)
        (resid_drop): Dropout(p=0.1, inplace=False)
        (proj): Linear(in_features=512, out_features=512, bias=True)
      )
      (mlp): Sequential(
        (0): Linear(in_features=512, out_features=2048, bias=True)
        (1): GELU()
        (2): Linear(in_features=2048, out_features=512, bias=True)
        (3): Dropout(p=0.1, inplace=False)
      )
    )
    (4): Block(
      (ln1): LayerNorm((512,), eps=1e-05, elementwise_affine=True)
      (ln2): LayerNorm((512,), eps=1e-05, elementwise_affine=True)
      (attn): CausalSelfAttention(
        (key): Linear(in_features=512, out_features=512, bias=True)
        (query): Linear(in_features=512, out_features=512, bias=True)
        (value): Linear(in_features=512, out_features=512, bias=True)
        (attn_drop): Dropout(p=0.1, inplace=False)
        (resid_drop): Dropout(p=0.1, inplace=False)
        (proj): Linear(in_features=512, out_features=512, bias=True)
      )
      (mlp): Sequential(
        (0): Linear(in_features=512, out_features=2048, bias=True)
        (1): GELU()
        (2): Linear(in_features=2048, out_features=512, bias=True)
        (3): Dropout(p=0.1, inplace=False)
      )
    )
    (5): Block(
      (ln1): LayerNorm((512,), eps=1e-05, elementwise_affine=True)
      (ln2): LayerNorm((512,), eps=1e-05, elementwise_affine=True)
      (attn): CausalSelfAttention(
        (key): Linear(in_features=512, out_features=512, bias=True)
        (query): Linear(in_features=512, out_features=512, bias=True)
        (value): Linear(in_features=512, out_features=512, bias=True)
        (attn_drop): Dropout(p=0.1, inplace=False)
        (resid_drop): Dropout(p=0.1, inplace=False)
        (proj): Linear(in_features=512, out_features=512, bias=True)
      )
      (mlp): Sequential(
        (0): Linear(in_features=512, out_features=2048, bias=True)
        (1): GELU()
        (2): Linear(in_features=2048, out_features=512, bias=True)
        (3): Dropout(p=0.1, inplace=False)
      )
    )
    (6): Block(
      (ln1): LayerNorm((512,), eps=1e-05, elementwise_affine=True)
      (ln2): LayerNorm((512,), eps=1e-05, elementwise_affine=True)
      (attn): CausalSelfAttention(
        (key): Linear(in_features=512, out_features=512, bias=True)
        (query): Linear(in_features=512, out_features=512, bias=True)
        (value): Linear(in_features=512, out_features=512, bias=True)
        (attn_drop): Dropout(p=0.1, inplace=False)
        (resid_drop): Dropout(p=0.1, inplace=False)
        (proj): Linear(in_features=512, out_features=512, bias=True)
      )
      (mlp): Sequential(
        (0): Linear(in_features=512, out_features=2048, bias=True)
        (1): GELU()
        (2): Linear(in_features=2048, out_features=512, bias=True)
        (3): Dropout(p=0.1, inplace=False)
      )
    )
    (7): Block(
      (ln1): LayerNorm((512,), eps=1e-05, elementwise_affine=True)
      (ln2): LayerNorm((512,), eps=1e-05, elementwise_affine=True)
      (attn): CausalSelfAttention(
        (key): Linear(in_features=512, out_features=512, bias=True)
        (query): Linear(in_features=512, out_features=512, bias=True)
        (value): Linear(in_features=512, out_features=512, bias=True)
        (attn_drop): Dropout(p=0.1, inplace=False)
        (resid_drop): Dropout(p=0.1, inplace=False)
        (proj): Linear(in_features=512, out_features=512, bias=True)
      )
      (mlp): Sequential(
        (0): Linear(in_features=512, out_features=2048, bias=True)
        (1): GELU()
        (2): Linear(in_features=2048, out_features=512, bias=True)
        (3): Dropout(p=0.1, inplace=False)
      )
    )
  )
  (ln_f): LayerNorm((512,), eps=1e-05, elementwise_affine=True)
  (head): Linear(in_features=512, out_features=30522, bias=False)
)

import torch

x = torch.tensor([indexes]).long()
output, _ = model(x)
output.shape

torch.Size([1, 11, 30522])

GPT implementa un tipo de mecanismo de atenci칩n causal, esto significa que cada palabra solo puede atender a las palabras anteriores. De esta manera evitamos que el modelo sea capaz de ver en el futuro durante el entrenamiento. En fase de inferencia, tendremos que predecir palabra a palabra, usando las predicciones como nuevos inputs para seguir prediciendo.
from minGPT.mingpt.utils import sample

new_words = 3
y = sample(model, x, new_words, temperature=1.0, sample=True, top_k=10)[0]

y = tokenizer.convert_ids_to_tokens(y)
' '.join(y)

'def add _ numbers ( a , b ) : return invention shelf isaac'

Podemos quedarnos con aquellas palabras con la mayor probabilidad o, lo que es m치s com칰n, samplear opciones siguiendo la distribuci칩n de probabilidad para generar diferentes posibilidades. Sin embargo, para que todo funciones, antes tendremos que entrenar nuestro modelo para que aprenda a generar c칩digo.
Entrenamiento
Como siempre os recomiendo, vamos a empezar haciendo el fit de una sola muestra para asegurarnos que todo est치 bien. Como los transformers trabajan con entradas de longitud fija vamos a a침adir el token pad para rellenar los huecos que haga falta. Adem치s, a침adiremos los tokens de inicio y final de frase para que el modelo sepa cuando terminar de predecir nuevas palabras.
max_input_length = tokenizer.max_model_input_sizes['bert-base-uncased']

class Dataset(torch.utils.data.Dataset):
    def __init__(self, examples):
        self.examples = examples

    def __len__(self):
        return len(self.examples)

    def __getitem__(self, ix):
        tokens = tokenizer.tokenize(self.examples[ix])
        tokens = tokens[:max_input_length-2]

        input = [tokenizer.cls_token_id] + \
            tokenizer.convert_tokens_to_ids(tokens) + \
            [tokenizer.pad_token_id] * (512 - len(tokens) - 1)

        target = tokenizer.convert_tokens_to_ids(tokens) + \
            [tokenizer.sep_token_id] + \
            [tokenizer.pad_token_id] * (512 - len(tokens) - 1)

        assert len(input) == 512
        assert len(target) == 512

        return torch.LongTensor(input), torch.LongTensor(target)

ds = Dataset(['def add_numbers(a, b):\n return a + b'])

inputs, target = ds[0]
inputs[:17], target[:17]

(tensor([  101, 13366,  5587,  1035,  3616,  1006,  1037,  1010,  1038,  1007,
          1024,  2709,  1037,  1009,  1038,     0,     0]),
 tensor([13366,  5587,  1035,  3616,  1006,  1037,  1010,  1038,  1007,  1024,
          2709,  1037,  1009,  1038,   102,     0,     0]))

El target es igual que el input pero corrido un token a la derecha, as칤 para cada input el modelo intentar치 predecir la siguiente palabra. El primer token del input es el token de inicio de frase, para lo que el modelo nos dar치 la primera palabra. El 칰ltimo token del target es el token de final de frase, as칤 cuando el modelo reciba la 칰ltima palabra nos dar치 este token indicando que ya no debe predecir m치s. El token de padding sirve simplemente para tener una frase de longitud determinada.
dl = torch.utils.data.DataLoader(ds, batch_size=1, shuffle=False)

x, y = next(iter(dl))
x.shape, y.shape

(torch.Size([1, 512]), torch.Size([1, 512]))

Para entrenar, usaremos Pytorch Lightning.
import pytorch_lightning as pl

class Module(pl.LightningModule):
    def __init__(self, model, tconf):
        super().__init__()
        self.model = model
        self.tconf = tconf

    def forward(self, x):
        return self.model(x)[0]

    def training_step(self, batch, batch_idx):
        y, loss = self.model(*batch)
        return loss

    def validation_step(self, batch, batch_idx):
        y, loss = self.model(*batch)
        self.log('val_loss', loss.item())

    def configure_optimizers(self):
        return self.model.configure_optimizers(self.tconf)


from minGPT.mingpt.trainer import TrainerConfig

mconf = GPTConfig(tokenizer.vocab_size, block_size=512, n_layer=8, n_head=8, n_embd=512)
model = GPT(mconf)
tconf = TrainerConfig(weight_decay=0.1, learning_rate=3e-4, betas=(0.9, 0.95))

module = Module(model, tconf)

trainer = pl.Trainer(
    gpus=1,
    max_epochs=100,
    precision=16,
    overfit_batches=1,
    logger=False,
    checkpoint_callback=False,
)

trainer.fit(module, dl)

Using 16bit native Automatic Mixed Precision (AMP)
GPU available: True, used: True
TPU available: False, using: 0 TPU cores
IPU available: False, using: 0 IPUs
LOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1]

  | Name  | Type | Params
-------------------------------
0 | model | GPT  | 56.7 M
-------------------------------
56.7 M    Trainable params
0         Non-trainable params
56.7 M    Total params
113.474   Total estimated model params size (MB)
/home/juan/miniconda3/lib/python3.9/site-packages/pytorch_lightning/trainer/data_loading.py:111: UserWarning: The dataloader, train_dataloader, does not have many workers which may be a bottleneck. Consider increasing the value of the `num_workers` argument` (try 20 which is the number of cpus on this machine) in the `DataLoader` init to improve performance.
  rank_zero_warn(



Training: 0it [00:00, ?it/s]

tokens = tokenizer.tokenize('def add_numbers(a, b):')
indexes = [tokenizer.cls_token_id] + tokenizer.convert_tokens_to_ids(tokens)

x = torch.tensor([indexes]).long()
new_words = 5
y = sample(model, x, new_words)[0]

y = tokenizer.convert_ids_to_tokens(y)
' '.join(y)

'[CLS] def add _ numbers ( a , b ) : return a + b [SEP]'

!Genial! Nuestro modelo ha sido capaz de aprenderse de memoria una sola muestra. Ahora tenemos que entrenar con todo el dataset.
train_path = Path('data/codeparrot-clean-train')
val_path = Path('data/codeparrot-clean-valid')

train_files = glob(str(train_path) + '/*.json.gz')
val_files = glob(str(val_path) + '/*.json.gz')

len(train_files), len(val_files)

(52, 1)

train_file = pd.read_json(train_files[0], lines=True) # le paso s칩lo un archivo, no se c칩mo hacer que los use todos 游
val_file = pd.read_json(val_files[0], lines=True)

ds = {
    'train': Dataset(train_file.content.values),
    'val': Dataset(val_file.content.values),
}

len(ds['train']), len(ds['val'])

(100000, 61373)

dl = {
    'train': torch.utils.data.DataLoader(ds['train'], batch_size=32, shuffle=True, num_workers=20, pin_memory=True),
    'val': torch.utils.data.DataLoader(ds['val'], batch_size=32, shuffle=False, num_workers=20, pin_memory=True),
}

mconf = GPTConfig(tokenizer.vocab_size, block_size=512, n_layer=8, n_head=8, n_embd=512)
model = GPT(mconf)
tconf = TrainerConfig(weight_decay=0.1, learning_rate=3e-4, betas=(0.9, 0.95))

module = Module(model, tconf)

trainer = pl.Trainer(
    gpus=1,
    max_epochs=3,
    precision=16,
    limit_val_batches=100,
)

trainer.fit(module, dl['train'], dl['val'])

Using 16bit native Automatic Mixed Precision (AMP)
GPU available: True, used: True
TPU available: False, using: 0 TPU cores
IPU available: False, using: 0 IPUs
LOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0,1]

  | Name  | Type | Params
-------------------------------
0 | model | GPT  | 56.7 M
-------------------------------
56.7 M    Trainable params
0         Non-trainable params
56.7 M    Total params
113.474   Total estimated model params size (MB)



Validation sanity check: 0it [00:00, ?it/s]



Training: 0it [00:00, ?it/s]



Validating: 0it [00:00, ?it/s]



Validating: 0it [00:00, ?it/s]



Validating: 0it [00:00, ?it/s]

tokens = tokenizer.tokenize('def add_numbers(a, b):')
indexes = [tokenizer.cls_token_id] + tokenizer.convert_tokens_to_ids(tokens)

x = torch.tensor([indexes]).long()
new_words = 5
y = sample(model, x, new_words)[0]

y = tokenizer.convert_ids_to_tokens(y)
' '.join(y)

'[CLS] def add _ numbers ( a , b ) : return a + b [SEP]'

춰Voil치! Ya tenemos nuestro modelo GPT para generaci칩n de c칩gido 游댠 Para obtener un buen resultado tendr치s que entrenar m치s epochs, con todos los datos, un modelo m치s grande (puedes usar los papers de GPT2 y GPT3 para guiarte), etc.
Resumen
En este post hemos visto c칩mo entrenar una red neuronal para generaci칩n de c칩digo Python inspir치ndonos en Github Copilot. Aqu칤 he utilizado diferentes librer칤as y herramientas, pero como comentaba al principio del post en este hilo encontrar치s c칩mo hacer lo mismo con las librer칤as de Huggingface, lo cu치l simplifica mucho todo y probablemete te permita conseguir muchos mejores resultados. En pr칩ximos posts entraremos m치s en detalle en el ecosistema de Huggingface. Te animo a que juegues un poco con el c칩digo, entrenando diferentes versiones del modelo. Para pasar al siguiente nivel, puedes exportar el modelo y desplegarlo en una API, hosteada en Heroku por ejemplo, y hacer una extensi칩n de VSCode que llame a la API para sugerir c칩digo directamente en el editor. Si lo haces, comp치rtelo en nuestro discord con el resto de la comunidad 游뱅
