
La Librería Estándar de Python
En posts anteriores hemos visto cómo manejarnos con la sintaxis básica de Python, desde los conceptos más básicos como crear variables o control de flujo hasta conceptos más avanzados como clases, pasando también por diferentes estructuras de datos y funciones. Estos conceptos forman el núcleo del lenguaje. Aún así, al trabajar con Python, tenemos muchas otras características y funcionalidad que podemos aprovechar para el análisis de datos sin necesidad de recurrir a librerías externas. Algunos ejemplos incluyen: trabajar con archivos (IO), acceder a funcionalidad del sistema operativo, operaciones matemáticas comunes, comprimir o descomprimir archivos, y un larguísimo etcétera. Esta funcionalidad viene implementada en diferentes módulos en lo que se conoce como la librería estándar de Python, o STL (STandard Library). En este post vamos a ver algunos de los módulos más utilizados en el análisis de datos. Puedes ver una lista completa de todos los módulos disponibles aquí.   
Módulos matemáticos
El módulo math
Este módulo nos da acceso a multitud de funciones matemáticas. Estos son algunos ejemplos. 
import math


⚠️ Para importar cualquier módulo de la librería estándar utilizamos la palabra import seguida del nombre de la librería, en este caso math.

# valor absoluto

math.fabs(-1)

1.0

# redondear un valor al alza

math.ceil(2.1)

3

# redondear un valor a la baja

math.floor(2.1)

2

# función exponencial

math.exp(1)

2.718281828459045

# función logarítmica

math.log(1)

0.0

# potenciación

math.pow(2, 2)

4.0

# raíz cuadrada

math.sqrt(4)

2.0

# funciones trigonométricas

math.cos(45)

# también tenemos sin, tan ...

0.5253219888177297

# constantes

math.pi

3.141592653589793

math.e

2.718281828459045

Y muchas más funciones que puedes encontrar aquí.
El módulo random
Este módulo nos va a dar funcionalidad para trabajar con números (pseudo) aleatorios.
import random

# número aleatorio entre 0 y 1

random.random()

0.8499521141392985

random.random()

0.6065997727244846


⚠️ Como puedes ver, al trabajar con números aleatorios cada vez que ejecutamos alguna función el resultado va a ser diferente.

# valor aleatorio entre dos valores

random.uniform(3, 5)

4.69170673249722

# valor aleatorio siguiendo una distribución gausiana
# con media `mu` iy desviación estándar `sigma` 

mu = 2
sigma = 0.3
random.gauss(mu, sigma)

2.12423100921994

Puedes encontrar el resto de funcionalidad que la librería random ofrece aquí. Es importante remarcar que cuando trabajamos con valores aleatorios los resultados que obtengamos van a variar entre ejecuciones. Esto puede ser problemático a la hora de reproducir resultados. Este problema se puede evitar fijando la semilla (seed en inglés). 
random.seed(42)

random.random()

0.6394267984578837

Cada vez que ejecutemos la función anterior obtendremos un resultado diferente, sin embargo siempre obtendremos los mismos valores en repetidas ejecuciones. Este es el motivo por el que hablamos de valores pseudoaleatorios.
El módulo os
Este módulo nos dará acceso a funcionalidad del sistema operativo (como listar archivos, crear o eliminar carpetas, acceder a variables de entorno, ...). Esta funcionalidad es distinta en cada sistema operativo, sin embargo al utilizar Python disponemos de una manera unificada de trabajar independiente de si estamos en Windows, MacOS o Linux.
import os

# accede a las variables de entorno

os.environ

# recuperar el directorio actual

os.getcwd()

# obtiene una lista con todos los archivos en un directorio

os.listdir('.')

['.ipynb_checkpoints', 'hola.txt', 'python_stl.ipynb']


⚡ Para acceder a los archivos de la carpeta en la que te encuentras puedes usar .. Para otras localizaciones puedes usar el path relativo o absoluto.

# crear una carpeta

os.mkdir('test')
os.listdir('.')

['.ipynb_checkpoints', 'hola.txt', 'python_stl.ipynb', 'test']

# eliminar una carpeta

os.rmdir('test')
os.listdir('.')

['.ipynb_checkpoints', 'hola.txt', 'python_stl.ipynb']


⚠️ Si intentas eliminar una carpeta con contenido recibirás un error. Puedes solucionar esto utilizando el módulo shutil.

El módulo os nos da muchísima funcionalidad para interactuar con el sistema operativo, puedes encontrar muchos ejemplos aquí.
El módulo io
Puedes leer una archivo con la función open(). Al ser una función tan utilizada no es necesario importar el módulo io.
f = open('hola.txt')

Podemos obtener cada línea dentro del archivo iterando de la siguiente manera
for l in f:
    print(l)

Esto es un archivo de prueba, esta es la primera linea.

Esta es la segunda linea.

Este módulo nos permite también escribir archivos. Puedes ver más opciones aquí. Sin embargo, normalmente trabajamos con archivos en un formato concreto (por ejemplo archivos csv o imágenes png o jpg) por lo que utilizaremos funciones específicas optimizadas para cada caso, definidas en librerías cono pandas o scikit-image.
Lanzando tareas en paralelo
En el proceso de análisis de datos es común ejecutar transformaciones u otras funciones sobre una gran cantidad de datos. Estos procesos pueden tardar mucho tiempo, y en ocasiones podemos aprovechar el hecho que la mayoría de CPUs tienen varios cores para ejecutar tareas en paralelo.
import time

def func(p):
    print(f"Soy el proceso {p}")
    time.sleep(1)
    return 2*p

p = [1, 2, 3, 4]

%time results = [func(_p) for _p in p]

results

Soy el proceso 1
Soy el proceso 2
Soy el proceso 3
Soy el proceso 4
Wall time: 4.04 s





[2, 4, 6, 8]

El código anterior ejecuta la función func de manera secuencial. La función time.sleep hace que Python se pause por el tiempo indicado (en este caso 1 segundo). De esta manera podemos simular una función muy pesada.

⚡ Al trabajar con notebooks tenemos a nuestra disposición los llamados comandos mágicos que nos ofrecen cierta funcionalidad. En este caso hemos usado el comando %time para saber cuanto tiempo tarda en ejecutarse una línea. Puedes ver otros comandos mágicos aquí.

Vamos a ver ahora como ejecutar esta función en paralelo.
import concurrent.futures

with concurrent.futures.ThreadPoolExecutor() as executor:
    %time results = list(executor.map(func, p))

results

Soy el proceso 1
Soy el proceso 2
Soy el proceso 3
Soy el proceso 4
Wall time: 1.02 s





[2, 4, 6, 8]

Como puedes ver se han ejecutado las 4 funciones a la vez (esto dependerá del número de cores de la CPU en la que se ejecute la función. Por defecto, el módulo concurrent.futures utilizará todos los cores disponibles). Esto nos puede dar un aumento de la velocidad de ejecución de nuestro código, lo cual implica un aumento considerable en nuestra productividad. Puedes explorar todas las opciones de procesado en paralelo que Python ofrece aquí.
Otros módulos interesantes
La librería estándar de Python es muy extensa y llena de funcionalidad. De entre todos los módulos existentes, otros que te recomiendo explorar por su utilidad a la hora de llevar a cabo análisis de datos son los siguientes:

json nos permite trabajar con datos y archivos en formato json.
argparse es un módulo muy útil para el parseado de argumentos en línea de comandos (útil cuando ejecutamos scripts de Python por consola).
pickle implementa protocolos para la serialización de objetos de Python. Esto nos permitirá guardar objetos enteros en archivos que luego podemos cargar de nuevo (útil para guardar modelos de IA una vez entrenados o pipelines de transformación de datos para utilizarlos más tarde).
Compresión de datos: Aquí encontrarás varios módulos para comprimir y descomprimir archivos en varios formatos como zip o tar.
urllib es un módulo útil para descargar datos de internet directamente desde URLs.

Resumen
En este post hemos visto como llevar a cabo muchas tareas comunes en el proceso del análisis de datos utilizando diferentes módulos implementados en la librería estándar de Python. Algunos ejemplos son los módulos math o random que implementan funciones matemáticas, el módulo os para interactuar con el sistema operativo, el módulo io para trabajar leer y escribir archivos y otros módulos interesantes para la ejecución de funciones en paralelo, la descarga de archivos de internet a través de URL, la descompresión de archivos, etc. Si bien estos módulos implementan funcionalidad muy útil para el análisis de datos, otros módulos externos (no disponibles en la librería estándar y que por lo tanto tendremos que instalar) nos ofrecerán mayor funcionalidad e implementaciones optimizadas. Algunos ejemplos son Numpy o Pandas, librerías que aprenderemos a utilizar en próximos posts.
