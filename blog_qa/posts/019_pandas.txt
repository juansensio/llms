
Pandas
La librer√≠a Pandas proporciona estructuras de datos y herramientas de an√°lisis de datos f√°ciles de usar y optimizadas. De la misma forma que en Numpy el objeto principal era el ndarray (en este post puedes aprender sobre Numpy) el objeto principal en Pandas es el DataFrame, que puede considerarse como una tabla alojada en memoria (como una hoja de c√°lculo de Excel, con nombres de columna y etiquetas de fila). Muchas funciones disponibles en Excel est√°n disponibles mediante programaci√≥n, como crear tablas din√°micas, calcular columnas basadas en otras columnas, hacer gr√°ficos, etc. Pandas se construye por encima de Numpy, por lo que podremos aprovechar mucha de la funcionalidad y nomenclatura ya conocemos. La principal diferencia es que con Pandas vamos a poder trabajar con datos heterog√©neos, mientras que en Numpy necesitamos que nuestras estructuras de datos sean siempre del mismo tipo para poder llevar a cabo operaciones. Para poder empezar a trabajar con Pandas simplemente tenemos que importarlo como cualquier otra librer√≠a.
import pandas as pd


üí°Es com√∫n importar Pandas con el nombre pd. Recuerda que si no tienes instalada la librer√≠a puedes hacerlo con pip install pandas o bien conda install pandas si instalaste Python con Anaconda.

El objeto Series
Si bien el objeto principal en Pandas hemos dicho que es el DataFrame, un DataFrame est√° formado por una colecci√≥n de Series. Es por esto que empezamos explicando este objeto b√°sico. Una Series es un objeto unidimensional similar a una lista o un array que contiene una secuencia de valores del mismo tipo. Cada elemento en la Series tiene tambi√©n una etiqueta asociada, llamada √≠ndice. Podemos crear una Series de la siguiente manera.
s = pd.Series([2,-1,3,5])
s

0    2
1   -1
2    3
3    5
dtype: int64

Puedes ver la lista con todos los valores (columna de la derecha) y sus √≠ndices correspondientes (columna de la izquierda). Al no haber definido √≠ndices, Pandas asigna por defecto la posici√≥n de cada valor en la secuencia. Podemos asignar etiquetas al crear una Series de la siguiente manera
s2 = pd.Series([68, 83, 112, 68], index=["alice", "bob", "charles", "darwin"])
s2

alice       68
bob         83
charles    112
darwin      68
dtype: int64

Indexado
Esto nos permite indexar los valores de la Series utilizando su √≠ndice de manera similar a cuando utilizamos un dict de Python.
s2['alice']

68

Aunque podemos seguir indexando valores directamente por su posici√≥n en la secuencia
s2[0]

68

Podemos utilizar una nomenclatura alternativa para explicitar de qu√© manera estamos accediendo a los valores en una Series, que tambi√©n podremos usar en un DataFrame.
# acceder por etiqueta

s2.loc['alice']

68

# acceder por √≠nidice

s2.iloc[0]

68

Como puedes ver una Series es muy similar a un dict, de hecho la manera m√°s com√∫n de inicializar objetos en Pandas es a partir de dicts.
data = {"alice": 68, "bob": 83, "colin": 86, "darwin": 68}
s3 = pd.Series(data)
s3

alice     68
bob       83
colin     86
darwin    68
dtype: int64

Operaciones
Podemos operar con Series como si de arrays de Numpy se tratase, y muchas funciones de Numpy aceptan Series como argumentos.
s3 + 2

alice     70
bob       85
colin     88
darwin    70
dtype: int64

s3 * 2

alice     136
bob       166
colin     172
darwin    136
dtype: int64

import numpy as np

np.exp(s3)

alice     3.404276e+29
bob       1.112864e+36
colin     2.235247e+37
darwin    3.404276e+29
dtype: float64


‚ö° Las reglas del broadcasting que aprendimos en este post siguen aplic√°ndose en Pandas.

Y tambi√©n, del mismo modo, utilizar todas las reglas de indexaci√≥n que aprendimos para Numpy, como por ejemplo el slicing y el masking.
# escoger los dos √∫ltimos elementos

s3[-2:]

colin     86
darwin    68
dtype: int64

# filtrado

s3[s3 > 80]

bob      83
colin    86
dtype: int64

Tambi√©n podemos llevar a cabo operaciones entre Series, en estos casos Pandas alinear√° de manera autom√°tica los diferentes objetos para hacer coincidir las mismas etiquetas. El resultado ser√° la uni√≥n de las diferentes Series, introduciendo el valor NaN (not a number) para aquellas etiquetas que no est√©n presente en todos los objetos involucrados.
s2 = pd.Series({"alice": 68, "bob": 83, "colin": 86, "darwin": 68})
s3 = pd.Series({"alice": 68, "bob": 83, "charles": 86, "darwin": 68})

s2 + s3

alice      136.0
bob        166.0
charles      NaN
colin        NaN
darwin     136.0
dtype: float64

Visualizaci√≥n
Por √∫ltimo, podemos visualizar los datos en una Series gracias a su integraci√≥n con Matplotlib, una librer√≠a de visualizaci√≥n muy √∫til de la cual hablaremos en futuros posts. Aqu√≠ puedes ver un ejemplo para visualizar todos los valores alamacenados en una Series, simplemente llamando a la funci√≥n plot() directamente sobre el objeto.
%matplotlib inline
import matplotlib.pyplot as plt

temperatures = [4.4,5.1,6.1,6.2,6.1,6.1,5.7,5.2,4.7,4.1,3.9,3.5]
s = pd.Series(temperatures, name="Temperature")
s.plot()
plt.show()



En futuros posts encontrar√°s como trabajar con Matplotlib para generar visualizaciones con calidad para art√≠culos o informes. Aprender√°s c√≥mo a√±adir t√≠tulos a la gr√°ficas, customizar los ejes, a√±adir varias Series en una misma gr√°fica, generar visualizaciones con varias gr√°ficas a la vez e incluso generar animaciones que podr√°s descargar como v√≠deos o gifs.

El objeto DataFrame
Puedes ver un DataFrame como una hoja de c√°lculo, con valores en celdas, nombres de columna y etiquetas de √≠ndice para cada fila. Permite definir expresiones para calcular columnas basadas en otras columnas, crear tablas din√°micas, agrupar filas, dibujar gr√°ficos, etc. Ahora que conocemos el objeto Series, tambi√©n podemos ver un DataFrames como diccionarios de Series.
data = {
    "weight": pd.Series([68, 83, 112], index=["alice", "bob", "charles"]),
    "birthyear": pd.Series([1984, 1985, 1992], index=["bob", "alice", "charles"], name="year"),
    "children": pd.Series([0, 3], index=["charles", "bob"]),
    "hobby": pd.Series(["Biking", "Dancing"], index=["alice", "bob"]),
}

df = pd.DataFrame(data)

df







weight
birthyear
children
hobby




alice
68
1985
NaN
Biking


bob
83
1984
3.0
Dancing


charles
112
1992
0.0
NaN




Como puedes ver las diferentes Series han sido alineadas autom√°ticamente, a√±adiendo valores NaN en aquellas entradas no presentes en una Series determinada pero que s√≠ aparecen en otras. Estos valores se conocen como missing values, y m√°s adelante hablamos de diferente funcionalidad que Pandas nos ofrece para tratarlos, ya que nuestros modelos de Machine Learning no son capaces de trabajar con este tipo de valores. Igual que hemos visto anteriormente, la forma m√°s com√∫n de crear un DataFrame es a partir de un dict.
df = pd.DataFrame({
    "birthyear": {"alice":1985, "bob": 1984, "charles": 1992},
    "hobby": {"alice":"Biking", "bob": "Dancing"},
    "weight": {"alice":68, "bob": 83, "charles": 112},
    "children": {"bob": 3, "charles": 0}
})

df







birthyear
hobby
weight
children




alice
1985
Biking
68
NaN


bob
1984
Dancing
83
3.0


charles
1992
NaN
112
0.0




Es posible tener estructuras de datos de m√°s de dos dimensiones, para ello tenemos que proveer a Pandas de √≠ndices de alto nivel
df2 = pd.DataFrame(
  {
    ("public", "birthyear"):
        {("Paris","alice"):1985, ("Paris","bob"): 1984, ("London","charles"): 1992},
    ("public", "hobby"):
        {("Paris","alice"):"Biking", ("Paris","bob"): "Dancing"},
    ("private", "weight"):
        {("Paris","alice"):68, ("Paris","bob"): 83, ("London","charles"): 112},
    ("private", "children"):
        {("Paris", "alice"):np.nan, ("Paris","bob"): 3, ("London","charles"): 0}
  }
)

df2








public
private




birthyear
hobby
weight
children




Paris
alice
1985
Biking
68
NaN


bob
1984
Dancing
83
3.0


London
charles
1992
NaN
112
0.0




Indexado
Podemos acceder a los valores de cualquier columna mediante su nombre.
df["weight"]

alice       68
bob         83
charles    112
Name: weight, dtype: int64

Como puedes ver el resultado es una Series con los valores y las etiquetas de todos los elementos de la columna. Podemos acceder a varias columnas a la vez mediante una lista de nombres
df[["weight", "birthyear"]]







weight
birthyear




alice
68
1985


bob
83
1984


charles
112
1992




En este caso el resultado es un nuevo DataFrame que contiene s√≥lo las columnas seleccionadas. Para acceder a los valores por filas, utilizamos la misma nomenclatura utilizada para indexar Series.
# indexamos con la etiqueta

df.loc["alice"]

birthyear      1985
hobby        Biking
weight           68
children        NaN
Name: alice, dtype: object

# indexamos con la posici√≥n

df.iloc[0]

birthyear      1985
hobby        Biking
weight           68
children        NaN
Name: alice, dtype: object

Crear y eliminar columnas
Podemos crear nuevas columnas de la siguiente manera
df["height"] = pd.Series({"alice": 167, "bob": 180})

df







birthyear
hobby
weight
children
height




alice
1985
Biking
68
NaN
167.0


bob
1984
Dancing
83
3.0
180.0


charles
1992
NaN
112
0.0
NaN




Del mismo modo, as√≠ es como eliminar√≠amos una columna
del df["height"]

df







birthyear
hobby
weight
children




alice
1985
Biking
68
NaN


bob
1984
Dancing
83
3.0


charles
1992
NaN
112
0.0




Por defecto, las nuevas columnas se a√±aden en la √∫ltima posici√≥n. Podemos insertar la columna en una posici√≥n determinada con la funci√≥n insert.
# a√±ade la nueva columna en la posici√≥n 2

df.insert(2, "height", pd.Series({"alice": 167, "bob": 180}))

df







birthyear
hobby
height
weight
children




alice
1985
Biking
167.0
68
NaN


bob
1984
Dancing
180.0
83
3.0


charles
1992
NaN
NaN
112
0.0




Tambi√©n podemos crear nuevas columnas a partir de otras de manera sencilla
df["w2h_ratio"] = df["weight"] / df["height"]

df







birthyear
hobby
height
weight
children
w2h_ratio




alice
1985
Biking
167.0
68
NaN
0.407186


bob
1984
Dancing
180.0
83
3.0
0.461111


charles
1992
NaN
NaN
112
0.0
NaN




Operaciones
Del mismo modo que con las Series, podemos llevar a cabo operaciones con DataFrames. En este caso tendremos que tener en cuenta que las operaciones est√©n definidas para todos los diferentes tipos de datos almacenados en el objeto.
df = df[["weight", "height"]]

df







weight
height




alice
68
167.0


bob
83
180.0


charles
112
NaN




df + 2







weight
height




alice
70
169.0


bob
85
182.0


charles
114
NaN




np.exp(df)







weight
height




alice
3.404276e+29
3.366499e+72


bob
1.112864e+36
1.489384e+78


charles
4.375039e+48
NaN




Podemos usar el indexado de tipo masking para filtrar los valores de un DataFrame.
df[df["weight"] > 80]







weight
height




bob
83
180.0


charles
112
NaN




df[(df["weight"] > 80) & (df["height"] >= 180)]







weight
height




bob
83
180.0




Visualizaci√≥n
Tambi√©n podemos utilizar la funci√≥n plot() sobre un DataFrame para visualizar los datos de manera r√°pida. Esto es especialmente √∫til cuando todos los datos que tenemos son de tipo num√©rico.
df.plot()
plt.show()



‚ö° Una manera muy r√°pida de visualizar todos los datos en un dict con listas de valores es crear un DataFrame y simplemente llamar a la funci√≥n plot(). 

Resumen
En este post hemos introducido la librer√≠a para el an√°lisis de datos Pandas. Este m√≥dulo, construido encima de Numpy, nos permite trabajar con datos tabulares gracias al objeto DataFrame. Este objeto nos permite llevar a cabo las operaciones b√°sicas para el an√°lisis de datos de manera eficiente y con una sintaxis sencilla. En los pr√≥ximos posts aprenderemos funcionalidad m√°s avanzada como por ejemplo ordenar, filtrar y seleccionar elementos, guardar y cargar datos de archivos, tratar missing values y trabajar con datos especiales de tipo categ√≥rico as√≠ como datos temporales.
