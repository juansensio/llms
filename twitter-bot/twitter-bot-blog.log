Starting new HTTPS connection (1): www.sensiocoders.com:443
https://www.sensiocoders.com:443 "GET /blog/ HTTP/1.1" 200 None
Starting new HTTPS connection (1): www.sensiocoders.com:443
https://www.sensiocoders.com:443 "GET /blog/005_python_clases HTTP/1.1" 200 None
message='Request to OpenAI API' method=post path=https://api.openai.com/v1/chat/completions
api_version=None data='{"messages": [{"role": "user", "content": "Tu tarea es leer el siguiente post y generar un tweet educativo en castellano.\\nDado el siguiente post, genera un tweet de m\\u00e1ximo 200 caracteres en castellano.\\nEl tweet debe ser educativo y accesible para diferentes niveles de expertos.\\nResponde siempre en espa\\u00f1ol.\\n\\nPOST:\\n\\n\\nClases\\nEn el post anterior hablamos sobre funciones, una manera que tenemos para organizar nuestro c\\u00f3digo permitiendo su reutilizaci\\u00f3n y robustez. Una funci\\u00f3n admite una serie de argumentos que utilizar\\u00e1 para llevar a cabo una tarea determinada y, opcionalmente, devolver un resultado. En muchas ocasiones, esta aproximaci\\u00f3n es suficiente. Sin embargo, en otras ocasiones, necesitaremos un extra de funcionalidad que conseguiremos usando una clase. Como ya vimos anteriormente, en Python todo son objetos. La mayor\\u00eda de estos objetos tienen m\\u00e9todos y atributos. Los m\\u00e9todos son funciones asociadas a un objeto en particular que nos van a permitir interactuar con sus atributos, otros objetos asicioados al objeto principal. Al definir una clase seremos capaces de crear nuestros propios objetos, con sus m\\u00e9todos y atributos. Adem\\u00e1s, gracias a la herencia seremos capaces de definir nuevos objetos a partir de otros aprovechando sus m\\u00e8todos y atributos y a\\u00f1adiendo aquello que sea necesario en cada momento. As\\u00ed pues, el uso de clases extiende la idea de reutilizaci\\u00f3n y robustez de c\\u00f3digo que vimos en las funciones a\\u00f1adiendo un extra de funcionalidad.\\nDefinici\\u00f3n de Clases\\nPodemos crear una clase de la siguiente manera:\\nclass MiClase:\\n    a = \\"hola\\"\\n    \\n    def func(self):\\n        print(self.a)\\n\\nDe la misma manera que para definir una funci\\u00f3n usamos la palabra def, para definir una clase usamos la palabra class seguida por el nombre de la clase (en el ejemplo MiClase pero puedes usar el nombre que quieras). Dentro de la clase, usando indentaci\\u00f3n, definimos el atributo a y el m\\u00e9todo func. Para instanciar un objeto de nuestra clase simplemente creamos una nueva variable que llame la clase.\\nx = MiClase()\\n\\nAhora, x es un objeto del tipo MiClase y por lo tanto tiene acceso a todos sus m\\u00e9todos y atributos. Para acceder a ellos usamos la siguiente nomenclatura.\\nx.a\\n\\n\'hola\'\\n\\nx.func()\\n\\nhola\\n\\n\\n\\u26a0\\ufe0f F\\u00edjate que en la funci\\u00f3n func pasamos como primer argumento self, y para utilizar la variable a accedemos a ella como self.a. Esta es la manera que tenemos en Python para acceder a los diferentes m\\u00e9todos y atributos de un objeto desde cualquier m\\u00e9todo.\\n\\nPython es un lenguaje muy flexible y nos permite a\\u00f1adir nuevos m\\u00e9todos o atributos (o modificar los ya existentes) a cualquier objeto.\\n# modificamos un atributo\\n\\nx.a = \\"hello\\"\\nx.a\\n\\n\'hello\'\\n\\n# a\\u00f1adimos un nuevo atributo\\n\\nx.b = \\"hola\\"\\nx.b\\n\\n\'hola\'\\n\\nEs importante remarcar que el a\\u00f1adir nuevos m\\u00e9todos o atributos a un objeto no los a\\u00f1adir\\u00e1 en la definici\\u00f3n de la clase original.\\ny = MiClase()\\n\\n# el atributo `b` no existe\\ny.b\\n\\n---------------------------------------------------------------------------\\n\\nAttributeError                            Traceback (most recent call last)\\n\\n<ipython-input-7-f64f348aaab1> in <module>\\n      2 \\n      3 # el atributo `b` no existe\\n----> 4 y.b\\n\\n\\nAttributeError: \'MiClase\' object has no attribute \'b\'\\n\\nEl constructor\\nCada vez que creemos un nuevo objeto de nuestra clase tendremos el mismo valor para el atributo a. Sin embargo, es muy com\\u00fan utilizar una misma clase con diferentes valores para el mismo atributo. Para ello podemos pasarle los valores con los que queremos inicializar nuestro objeto a trav\\u00e9s del constructor.\\nclass MiClase:\\n    \\n    # Constructor\\n    def __init__(self, a):\\n        self.a = a\\n    \\n    def func(self):\\n        print(self.a)\\n\\nx = MiClase(\\"hola\\")\\ny = MiClase(\\"hello\\")\\n\\nx.func()\\n\\nhola\\n\\ny.func()\\n\\nhello\\n\\n\\n\\u26a0\\ufe0f El constructor de una clase siempre se define mediante la funci\\u00f3n __init__(self, argumentos).\\n\\nSobrecarga de operadores\\nImagina que queremos sumar dos n\\u00fameros. En Python es tan f\\u00e1cil como.\\nx = 1\\ny = 2\\n\\nx + y\\n\\n3\\n\\n\\u00bfPodemos hacer lo mismo con nuestra clase?\\nx = MiClase(1)\\ny = MiClase(2)\\n\\nx + y\\n\\n---------------------------------------------------------------------------\\n\\nTypeError                                 Traceback (most recent call last)\\n\\n<ipython-input-13-9c40486136a8> in <module>\\n      2 y = MiClase(2)\\n      3 \\n----> 4 x + y\\n\\n\\nTypeError: unsupported operand type(s) for +: \'MiClase\' and \'MiClase\'\\n\\nLa respuesta es no, y el motivo es que nuestra clase no tiene definido el m\\u00e9todo suma. Podemos definirlo de la siguiente manera\\nclass MiClase:\\n    \\n    # Constructor\\n    def __init__(self, a):\\n        self.a = a\\n    \\n    # sobrecarga suma\\n    def __add__(self, other):\\n        return self.a + other.a\\n    \\n    def func(self):\\n        print(self.a)\\n\\nx = MiClase(1)\\ny = MiClase(2)\\n\\nx + y\\n\\n3\\n\\nAl definir el m\\u00e9todo __add__ ahora nuestra clase soporta el operador suma. Esto se conoce como sobrecarga de operadores y es especialmente \\u00fatil cuando hacemos an\\u00e1lisis de datos, ya que podremos trabajar con nuestras clases como si lo hici\\u00e9semos con cualquier otro objeto de Python de manera transparente. Podemos sobrecargar pr\\u00e1cticamente todos los operadores, aqu\\u00ed puedes encontrar una lista.\\nclass MiClase:\\n    \\n    # Constructor\\n    def __init__(self, a):\\n        self.a = a\\n    \\n    # sobrecarga suma\\n    def __add__(self, other):\\n        return self.a + other.a\\n    \\n    # sobrecarga string (controlamos lo que se ve al hacer un `print` de nuestro objeto)\\n    def __str__(self):\\n        return f\'El valor de `a` es {self.a}\' \\n    \\n    def func(self):\\n        print(self.a)\\n\\nx = MiClase(1.56)\\n\\nprint(x)\\n\\nEl valor de `a` es 1.56\\n\\nPodemos utilizar esta sobrecarga de operadores para definir clases que puedan ser iterables (de forma an\\u00e1loga a los generadores que vimos en el post anterior).\\nclass MiIterador:\\n    \\n    # Constructor\\n    def __init__(self, n):\\n        self.items = [i for i in range(n)]\\n    \\n    # longitud del iterador\\n    def __len__(self):\\n        return len(self.items)\\n    \\n    # devolver valores al indexar nuestro iterador\\n    def __getitem__(self, ix):\\n        return self.items[ix]\\n\\nx = MiIterador(5)\\n\\nlen(x)\\n\\n5\\n\\nfor i in x:\\n    print(i)\\n\\n0\\n1\\n2\\n3\\n4\\n\\nDe esta manera podremos definir toda la l\\u00f3gica necesaria para cargar un dataset, que puede incluir cualquier n\\u00famero o tipos de transformaciones, y a la vez iterar sobre \\u00e9l como si fuese una simple lista.\\nEl operador  __call__\\nDe entre los diferentes operadores que podemos sobrecargar, el operador __call__ es muy interesante ya que nos va a permitir llamar a nuestro objeto como si de una funci\\u00f3n se tratase.\\nclass MiClase:\\n    \\n    def __init__(self, a):\\n        self.a = a\\n    \\n    def __call__(self, exp):\\n        return self.a**exp\\n\\nx = MiClase(2)\\n\\n# podemos usar nuestro objeto como una funci\\u00f3n\\nx(3)\\n\\n8\\n\\nEste patr\\u00f3n es muy utilizado en las diferentes librer\\u00edas de an\\u00e1lisis de datos, machine learning y deep learning que iremos viendo m\\u00e1s adelante.\\nHerencia\\nHablamos de herencia para referirnos al proceso de crear nuevas clases a partir de otras. Estas nuevas clases heredar\\u00e1n los m\\u00e9todos y atributos de sus clases progenitoras a la vez que nos permitir\\u00e1n a\\u00f1adir nueva funcionalidad.  \\nclass MiAlgoritmoBase:\\n    a = 1    \\n    def __call__(self):\\n        return 2*self.a\\n\\nclass MiAlgoritmo(MiAlgoritmoBase):\\n    \\n    def __init__(self, b):\\n        self.b = b\\n    \\n    def __call__(self):\\n        # el atributo `a` viene de la clase madre\\n        return 2*self.a + self.b\\n\\nx = MiAlgoritmoBase()\\n\\nx()\\n\\n2\\n\\nx = MiAlgoritmo(2)\\n\\nx()\\n\\n4\\n\\nEn el ejemplo anterior podemos ver una clase llamada MiAlgoritmoBase. Despu\\u00e9s, utilizamos esta clase para crear la nueva clase MiAlgoritmo. Como puedes ver, para crear la clase mediante herencia pasamos el nombre de la clase madre entre par\\u00e9ntesis en la definici\\u00f3n de la nueva clase. La nueva clase ahora tiene acceso a todos los m\\u00e9todos y atributos de la clase madre. Por otro lado, sobreescribimos la funci\\u00f3n __call__ por lo que al llamar a esta funci\\u00f3n en la nueva clase no llamamos a la funci\\u00f3n original de la clase madre, si no a la funci\\u00f3n de la nueva clase. \\n\\n\\u26a1 Como puedes ver el mecanismo de herencia es muy potente, permiti\\u00e9ndonos crear nuestro c\\u00f3digo poco a poco, encapsulando funcionalidad reutilizable en clases y creando nuevas clases de manera progresiva. Esta es la base de la Programaci\\u00f3n Orientada a Objetos, un paradigma de programaci\\u00f3n muy utilizado.\\n\\nHerencia m\\u00faltiple\\nPodemos crear una nueva clase a partir de varias clases progenitoras de la siguiente manera\\nclass MiAlgoritmoBase:    \\n    a = 1    \\n    def __call__(self):\\n        return 2*self.a\\n    \\nclass MiOtroAlgoritmoBase:    \\n    b = 2    \\n    def __call__(self):\\n        return -2*self.b\\n    \\nclass MiAlgoritmo(MiAlgoritmoBase, MiOtroAlgoritmoBase):\\n    \\n    # constructor\\n    def __init__(self, c):\\n        self.c = c\\n    \\n    def __call__(self):\\n        # los atributos `a` y `b` vienen de las clases progenitoras\\n        return (self.a + self.b)*self.c\\n\\nx = MiAlgoritmo(3)\\n\\nx()\\n\\n9\\n\\nEn la nueva clase tenemos acceso a todos los m\\u00e8todos y atributs de todas las clases progenitoras, a\\u00f1adiendo nuevas funciones o sobreescribiendo las ya existentes.\\nResumen\\nEn este post hemos visto como definir clases en Python, un recurso muy \\u00fatil a la hora de encapsular funcionalidad en un solo objeto con el que podemos interactuar como lo hacemos con el resto de objetos b\\u00e1sicos que Python nos ofrece. La mayor\\u00eda de algoritmos y estructuras de datos que usaremos de ahora en adelante est\\u00e1n definidos como clases de Python, con las que podremos interactuar mediante sus m\\u00e9todosy atributos. Gracias a la sobrecarga de operadores podremos utilizar los operadores m\\u00e1s comunes con nuestros propios objetos y tambi\\u00e9n nos permitir\\u00e1n crear iteradores. Por \\u00faltimo hemos hablado de herencia, un mecanismo que nos permite crear nuevas clases a partir de otras conservando los diferentes m\\u00e9todosy atributos de las clases progenitoras en la nueva clase, a\\u00f1adiendo o sobreescribiendo lo necesario para crear la nueva funcionalidad.\\n \\n\\nTWEET:"}], "model": "gpt-3.5-turbo-16k", "temperature": 0, "max_tokens": 256}' message='Post details'
Converted retries value: 2 -> Retry(total=2, connect=None, read=None, redirect=None, status=None)
Starting new HTTPS connection (1): api.openai.com:443
https://api.openai.com:443 "POST /v1/chat/completions HTTP/1.1" 200 None
message='OpenAI API response' path=https://api.openai.com/v1/chat/completions processing_ms=1355 request_id=54ba9b2740614449be74502c0f9634b0 response_code=200
message='Request to OpenAI API' method=post path=https://api.openai.com/v1/chat/completions
api_version=None data='{"messages": [{"role": "user", "content": "Tu tarea es leer el siguiente post y generar un tweet educativo en castellano.\\nDado el siguiente post, genera un tweet de m\\u00e1ximo 200 caracteres en castellano.\\nEl tweet debe ser educativo y accesible para diferentes niveles de expertos.\\nResponde siempre en espa\\u00f1ol.\\n\\nPOST:\\n\\n\\nClases\\nEn el post anterior hablamos sobre funciones, una manera que tenemos para organizar nuestro c\\u00f3digo permitiendo su reutilizaci\\u00f3n y robustez. Una funci\\u00f3n admite una serie de argumentos que utilizar\\u00e1 para llevar a cabo una tarea determinada y, opcionalmente, devolver un resultado. En muchas ocasiones, esta aproximaci\\u00f3n es suficiente. Sin embargo, en otras ocasiones, necesitaremos un extra de funcionalidad que conseguiremos usando una clase. Como ya vimos anteriormente, en Python todo son objetos. La mayor\\u00eda de estos objetos tienen m\\u00e9todos y atributos. Los m\\u00e9todos son funciones asociadas a un objeto en particular que nos van a permitir interactuar con sus atributos, otros objetos asicioados al objeto principal. Al definir una clase seremos capaces de crear nuestros propios objetos, con sus m\\u00e9todos y atributos. Adem\\u00e1s, gracias a la herencia seremos capaces de definir nuevos objetos a partir de otros aprovechando sus m\\u00e8todos y atributos y a\\u00f1adiendo aquello que sea necesario en cada momento. As\\u00ed pues, el uso de clases extiende la idea de reutilizaci\\u00f3n y robustez de c\\u00f3digo que vimos en las funciones a\\u00f1adiendo un extra de funcionalidad.\\nDefinici\\u00f3n de Clases\\nPodemos crear una clase de la siguiente manera:\\nclass MiClase:\\n    a = \\"hola\\"\\n    \\n    def func(self):\\n        print(self.a)\\n\\nDe la misma manera que para definir una funci\\u00f3n usamos la palabra def, para definir una clase usamos la palabra class seguida por el nombre de la clase (en el ejemplo MiClase pero puedes usar el nombre que quieras). Dentro de la clase, usando indentaci\\u00f3n, definimos el atributo a y el m\\u00e9todo func. Para instanciar un objeto de nuestra clase simplemente creamos una nueva variable que llame la clase.\\nx = MiClase()\\n\\nAhora, x es un objeto del tipo MiClase y por lo tanto tiene acceso a todos sus m\\u00e9todos y atributos. Para acceder a ellos usamos la siguiente nomenclatura.\\nx.a\\n\\n\'hola\'\\n\\nx.func()\\n\\nhola\\n\\n\\n\\u26a0\\ufe0f F\\u00edjate que en la funci\\u00f3n func pasamos como primer argumento self, y para utilizar la variable a accedemos a ella como self.a. Esta es la manera que tenemos en Python para acceder a los diferentes m\\u00e9todos y atributos de un objeto desde cualquier m\\u00e9todo.\\n\\nPython es un lenguaje muy flexible y nos permite a\\u00f1adir nuevos m\\u00e9todos o atributos (o modificar los ya existentes) a cualquier objeto.\\n# modificamos un atributo\\n\\nx.a = \\"hello\\"\\nx.a\\n\\n\'hello\'\\n\\n# a\\u00f1adimos un nuevo atributo\\n\\nx.b = \\"hola\\"\\nx.b\\n\\n\'hola\'\\n\\nEs importante remarcar que el a\\u00f1adir nuevos m\\u00e9todos o atributos a un objeto no los a\\u00f1adir\\u00e1 en la definici\\u00f3n de la clase original.\\ny = MiClase()\\n\\n# el atributo `b` no existe\\ny.b\\n\\n---------------------------------------------------------------------------\\n\\nAttributeError                            Traceback (most recent call last)\\n\\n<ipython-input-7-f64f348aaab1> in <module>\\n      2 \\n      3 # el atributo `b` no existe\\n----> 4 y.b\\n\\n\\nAttributeError: \'MiClase\' object has no attribute \'b\'\\n\\nEl constructor\\nCada vez que creemos un nuevo objeto de nuestra clase tendremos el mismo valor para el atributo a. Sin embargo, es muy com\\u00fan utilizar una misma clase con diferentes valores para el mismo atributo. Para ello podemos pasarle los valores con los que queremos inicializar nuestro objeto a trav\\u00e9s del constructor.\\nclass MiClase:\\n    \\n    # Constructor\\n    def __init__(self, a):\\n        self.a = a\\n    \\n    def func(self):\\n        print(self.a)\\n\\nx = MiClase(\\"hola\\")\\ny = MiClase(\\"hello\\")\\n\\nx.func()\\n\\nhola\\n\\ny.func()\\n\\nhello\\n\\n\\n\\u26a0\\ufe0f El constructor de una clase siempre se define mediante la funci\\u00f3n __init__(self, argumentos).\\n\\nSobrecarga de operadores\\nImagina que queremos sumar dos n\\u00fameros. En Python es tan f\\u00e1cil como.\\nx = 1\\ny = 2\\n\\nx + y\\n\\n3\\n\\n\\u00bfPodemos hacer lo mismo con nuestra clase?\\nx = MiClase(1)\\ny = MiClase(2)\\n\\nx + y\\n\\n---------------------------------------------------------------------------\\n\\nTypeError                                 Traceback (most recent call last)\\n\\n<ipython-input-13-9c40486136a8> in <module>\\n      2 y = MiClase(2)\\n      3 \\n----> 4 x + y\\n\\n\\nTypeError: unsupported operand type(s) for +: \'MiClase\' and \'MiClase\'\\n\\nLa respuesta es no, y el motivo es que nuestra clase no tiene definido el m\\u00e9todo suma. Podemos definirlo de la siguiente manera\\nclass MiClase:\\n    \\n    # Constructor\\n    def __init__(self, a):\\n        self.a = a\\n    \\n    # sobrecarga suma\\n    def __add__(self, other):\\n        return self.a + other.a\\n    \\n    def func(self):\\n        print(self.a)\\n\\nx = MiClase(1)\\ny = MiClase(2)\\n\\nx + y\\n\\n3\\n\\nAl definir el m\\u00e9todo __add__ ahora nuestra clase soporta el operador suma. Esto se conoce como sobrecarga de operadores y es especialmente \\u00fatil cuando hacemos an\\u00e1lisis de datos, ya que podremos trabajar con nuestras clases como si lo hici\\u00e9semos con cualquier otro objeto de Python de manera transparente. Podemos sobrecargar pr\\u00e1cticamente todos los operadores, aqu\\u00ed puedes encontrar una lista.\\nclass MiClase:\\n    \\n    # Constructor\\n    def __init__(self, a):\\n        self.a = a\\n    \\n    # sobrecarga suma\\n    def __add__(self, other):\\n        return self.a + other.a\\n    \\n    # sobrecarga string (controlamos lo que se ve al hacer un `print` de nuestro objeto)\\n    def __str__(self):\\n        return f\'El valor de `a` es {self.a}\' \\n    \\n    def func(self):\\n        print(self.a)\\n\\nx = MiClase(1.56)\\n\\nprint(x)\\n\\nEl valor de `a` es 1.56\\n\\nPodemos utilizar esta sobrecarga de operadores para definir clases que puedan ser iterables (de forma an\\u00e1loga a los generadores que vimos en el post anterior).\\nclass MiIterador:\\n    \\n    # Constructor\\n    def __init__(self, n):\\n        self.items = [i for i in range(n)]\\n    \\n    # longitud del iterador\\n    def __len__(self):\\n        return len(self.items)\\n    \\n    # devolver valores al indexar nuestro iterador\\n    def __getitem__(self, ix):\\n        return self.items[ix]\\n\\nx = MiIterador(5)\\n\\nlen(x)\\n\\n5\\n\\nfor i in x:\\n    print(i)\\n\\n0\\n1\\n2\\n3\\n4\\n\\nDe esta manera podremos definir toda la l\\u00f3gica necesaria para cargar un dataset, que puede incluir cualquier n\\u00famero o tipos de transformaciones, y a la vez iterar sobre \\u00e9l como si fuese una simple lista.\\nEl operador  __call__\\nDe entre los diferentes operadores que podemos sobrecargar, el operador __call__ es muy interesante ya que nos va a permitir llamar a nuestro objeto como si de una funci\\u00f3n se tratase.\\nclass MiClase:\\n    \\n    def __init__(self, a):\\n        self.a = a\\n    \\n    def __call__(self, exp):\\n        return self.a**exp\\n\\nx = MiClase(2)\\n\\n# podemos usar nuestro objeto como una funci\\u00f3n\\nx(3)\\n\\n8\\n\\nEste patr\\u00f3n es muy utilizado en las diferentes librer\\u00edas de an\\u00e1lisis de datos, machine learning y deep learning que iremos viendo m\\u00e1s adelante.\\nHerencia\\nHablamos de herencia para referirnos al proceso de crear nuevas clases a partir de otras. Estas nuevas clases heredar\\u00e1n los m\\u00e9todos y atributos de sus clases progenitoras a la vez que nos permitir\\u00e1n a\\u00f1adir nueva funcionalidad.  \\nclass MiAlgoritmoBase:\\n    a = 1    \\n    def __call__(self):\\n        return 2*self.a\\n\\nclass MiAlgoritmo(MiAlgoritmoBase):\\n    \\n    def __init__(self, b):\\n        self.b = b\\n    \\n    def __call__(self):\\n        # el atributo `a` viene de la clase madre\\n        return 2*self.a + self.b\\n\\nx = MiAlgoritmoBase()\\n\\nx()\\n\\n2\\n\\nx = MiAlgoritmo(2)\\n\\nx()\\n\\n4\\n\\nEn el ejemplo anterior podemos ver una clase llamada MiAlgoritmoBase. Despu\\u00e9s, utilizamos esta clase para crear la nueva clase MiAlgoritmo. Como puedes ver, para crear la clase mediante herencia pasamos el nombre de la clase madre entre par\\u00e9ntesis en la definici\\u00f3n de la nueva clase. La nueva clase ahora tiene acceso a todos los m\\u00e9todos y atributos de la clase madre. Por otro lado, sobreescribimos la funci\\u00f3n __call__ por lo que al llamar a esta funci\\u00f3n en la nueva clase no llamamos a la funci\\u00f3n original de la clase madre, si no a la funci\\u00f3n de la nueva clase. \\n\\n\\u26a1 Como puedes ver el mecanismo de herencia es muy potente, permiti\\u00e9ndonos crear nuestro c\\u00f3digo poco a poco, encapsulando funcionalidad reutilizable en clases y creando nuevas clases de manera progresiva. Esta es la base de la Programaci\\u00f3n Orientada a Objetos, un paradigma de programaci\\u00f3n muy utilizado.\\n\\nHerencia m\\u00faltiple\\nPodemos crear una nueva clase a partir de varias clases progenitoras de la siguiente manera\\nclass MiAlgoritmoBase:    \\n    a = 1    \\n    def __call__(self):\\n        return 2*self.a\\n    \\nclass MiOtroAlgoritmoBase:    \\n    b = 2    \\n    def __call__(self):\\n        return -2*self.b\\n    \\nclass MiAlgoritmo(MiAlgoritmoBase, MiOtroAlgoritmoBase):\\n    \\n    # constructor\\n    def __init__(self, c):\\n        self.c = c\\n    \\n    def __call__(self):\\n        # los atributos `a` y `b` vienen de las clases progenitoras\\n        return (self.a + self.b)*self.c\\n\\nx = MiAlgoritmo(3)\\n\\nx()\\n\\n9\\n\\nEn la nueva clase tenemos acceso a todos los m\\u00e8todos y atributs de todas las clases progenitoras, a\\u00f1adiendo nuevas funciones o sobreescribiendo las ya existentes.\\nResumen\\nEn este post hemos visto como definir clases en Python, un recurso muy \\u00fatil a la hora de encapsular funcionalidad en un solo objeto con el que podemos interactuar como lo hacemos con el resto de objetos b\\u00e1sicos que Python nos ofrece. La mayor\\u00eda de algoritmos y estructuras de datos que usaremos de ahora en adelante est\\u00e1n definidos como clases de Python, con las que podremos interactuar mediante sus m\\u00e9todosy atributos. Gracias a la sobrecarga de operadores podremos utilizar los operadores m\\u00e1s comunes con nuestros propios objetos y tambi\\u00e9n nos permitir\\u00e1n crear iteradores. Por \\u00faltimo hemos hablado de herencia, un mecanismo que nos permite crear nuevas clases a partir de otras conservando los diferentes m\\u00e9todosy atributos de las clases progenitoras en la nueva clase, a\\u00f1adiendo o sobreescribiendo lo necesario para crear la nueva funcionalidad.\\n \\n\\nTWEET:"}], "model": "gpt-3.5-turbo-16k", "temperature": 0, "max_tokens": 256}' message='Post details'
https://api.openai.com:443 "POST /v1/chat/completions HTTP/1.1" 200 None
message='OpenAI API response' path=https://api.openai.com/v1/chat/completions processing_ms=1139 request_id=6dff2947984eb202ae9cd3929cac6eef response_code=200
message='Request to OpenAI API' method=post path=https://api.openai.com/v1/chat/completions
api_version=None data='{"messages": [{"role": "user", "content": "Tu tarea es leer el siguiente post y generar un tweet educativo en castellano.\\nDado el siguiente post, genera un tweet de m\\u00e1ximo 200 caracteres en castellano.\\nEl tweet debe ser educativo y accesible para diferentes niveles de expertos.\\nResponde siempre en espa\\u00f1ol.\\n\\nPOST:\\n\\n\\nClases\\nEn el post anterior hablamos sobre funciones, una manera que tenemos para organizar nuestro c\\u00f3digo permitiendo su reutilizaci\\u00f3n y robustez. Una funci\\u00f3n admite una serie de argumentos que utilizar\\u00e1 para llevar a cabo una tarea determinada y, opcionalmente, devolver un resultado. En muchas ocasiones, esta aproximaci\\u00f3n es suficiente. Sin embargo, en otras ocasiones, necesitaremos un extra de funcionalidad que conseguiremos usando una clase. Como ya vimos anteriormente, en Python todo son objetos. La mayor\\u00eda de estos objetos tienen m\\u00e9todos y atributos. Los m\\u00e9todos son funciones asociadas a un objeto en particular que nos van a permitir interactuar con sus atributos, otros objetos asicioados al objeto principal. Al definir una clase seremos capaces de crear nuestros propios objetos, con sus m\\u00e9todos y atributos. Adem\\u00e1s, gracias a la herencia seremos capaces de definir nuevos objetos a partir de otros aprovechando sus m\\u00e8todos y atributos y a\\u00f1adiendo aquello que sea necesario en cada momento. As\\u00ed pues, el uso de clases extiende la idea de reutilizaci\\u00f3n y robustez de c\\u00f3digo que vimos en las funciones a\\u00f1adiendo un extra de funcionalidad.\\nDefinici\\u00f3n de Clases\\nPodemos crear una clase de la siguiente manera:\\nclass MiClase:\\n    a = \\"hola\\"\\n    \\n    def func(self):\\n        print(self.a)\\n\\nDe la misma manera que para definir una funci\\u00f3n usamos la palabra def, para definir una clase usamos la palabra class seguida por el nombre de la clase (en el ejemplo MiClase pero puedes usar el nombre que quieras). Dentro de la clase, usando indentaci\\u00f3n, definimos el atributo a y el m\\u00e9todo func. Para instanciar un objeto de nuestra clase simplemente creamos una nueva variable que llame la clase.\\nx = MiClase()\\n\\nAhora, x es un objeto del tipo MiClase y por lo tanto tiene acceso a todos sus m\\u00e9todos y atributos. Para acceder a ellos usamos la siguiente nomenclatura.\\nx.a\\n\\n\'hola\'\\n\\nx.func()\\n\\nhola\\n\\n\\n\\u26a0\\ufe0f F\\u00edjate que en la funci\\u00f3n func pasamos como primer argumento self, y para utilizar la variable a accedemos a ella como self.a. Esta es la manera que tenemos en Python para acceder a los diferentes m\\u00e9todos y atributos de un objeto desde cualquier m\\u00e9todo.\\n\\nPython es un lenguaje muy flexible y nos permite a\\u00f1adir nuevos m\\u00e9todos o atributos (o modificar los ya existentes) a cualquier objeto.\\n# modificamos un atributo\\n\\nx.a = \\"hello\\"\\nx.a\\n\\n\'hello\'\\n\\n# a\\u00f1adimos un nuevo atributo\\n\\nx.b = \\"hola\\"\\nx.b\\n\\n\'hola\'\\n\\nEs importante remarcar que el a\\u00f1adir nuevos m\\u00e9todos o atributos a un objeto no los a\\u00f1adir\\u00e1 en la definici\\u00f3n de la clase original.\\ny = MiClase()\\n\\n# el atributo `b` no existe\\ny.b\\n\\n---------------------------------------------------------------------------\\n\\nAttributeError                            Traceback (most recent call last)\\n\\n<ipython-input-7-f64f348aaab1> in <module>\\n      2 \\n      3 # el atributo `b` no existe\\n----> 4 y.b\\n\\n\\nAttributeError: \'MiClase\' object has no attribute \'b\'\\n\\nEl constructor\\nCada vez que creemos un nuevo objeto de nuestra clase tendremos el mismo valor para el atributo a. Sin embargo, es muy com\\u00fan utilizar una misma clase con diferentes valores para el mismo atributo. Para ello podemos pasarle los valores con los que queremos inicializar nuestro objeto a trav\\u00e9s del constructor.\\nclass MiClase:\\n    \\n    # Constructor\\n    def __init__(self, a):\\n        self.a = a\\n    \\n    def func(self):\\n        print(self.a)\\n\\nx = MiClase(\\"hola\\")\\ny = MiClase(\\"hello\\")\\n\\nx.func()\\n\\nhola\\n\\ny.func()\\n\\nhello\\n\\n\\n\\u26a0\\ufe0f El constructor de una clase siempre se define mediante la funci\\u00f3n __init__(self, argumentos).\\n\\nSobrecarga de operadores\\nImagina que queremos sumar dos n\\u00fameros. En Python es tan f\\u00e1cil como.\\nx = 1\\ny = 2\\n\\nx + y\\n\\n3\\n\\n\\u00bfPodemos hacer lo mismo con nuestra clase?\\nx = MiClase(1)\\ny = MiClase(2)\\n\\nx + y\\n\\n---------------------------------------------------------------------------\\n\\nTypeError                                 Traceback (most recent call last)\\n\\n<ipython-input-13-9c40486136a8> in <module>\\n      2 y = MiClase(2)\\n      3 \\n----> 4 x + y\\n\\n\\nTypeError: unsupported operand type(s) for +: \'MiClase\' and \'MiClase\'\\n\\nLa respuesta es no, y el motivo es que nuestra clase no tiene definido el m\\u00e9todo suma. Podemos definirlo de la siguiente manera\\nclass MiClase:\\n    \\n    # Constructor\\n    def __init__(self, a):\\n        self.a = a\\n    \\n    # sobrecarga suma\\n    def __add__(self, other):\\n        return self.a + other.a\\n    \\n    def func(self):\\n        print(self.a)\\n\\nx = MiClase(1)\\ny = MiClase(2)\\n\\nx + y\\n\\n3\\n\\nAl definir el m\\u00e9todo __add__ ahora nuestra clase soporta el operador suma. Esto se conoce como sobrecarga de operadores y es especialmente \\u00fatil cuando hacemos an\\u00e1lisis de datos, ya que podremos trabajar con nuestras clases como si lo hici\\u00e9semos con cualquier otro objeto de Python de manera transparente. Podemos sobrecargar pr\\u00e1cticamente todos los operadores, aqu\\u00ed puedes encontrar una lista.\\nclass MiClase:\\n    \\n    # Constructor\\n    def __init__(self, a):\\n        self.a = a\\n    \\n    # sobrecarga suma\\n    def __add__(self, other):\\n        return self.a + other.a\\n    \\n    # sobrecarga string (controlamos lo que se ve al hacer un `print` de nuestro objeto)\\n    def __str__(self):\\n        return f\'El valor de `a` es {self.a}\' \\n    \\n    def func(self):\\n        print(self.a)\\n\\nx = MiClase(1.56)\\n\\nprint(x)\\n\\nEl valor de `a` es 1.56\\n\\nPodemos utilizar esta sobrecarga de operadores para definir clases que puedan ser iterables (de forma an\\u00e1loga a los generadores que vimos en el post anterior).\\nclass MiIterador:\\n    \\n    # Constructor\\n    def __init__(self, n):\\n        self.items = [i for i in range(n)]\\n    \\n    # longitud del iterador\\n    def __len__(self):\\n        return len(self.items)\\n    \\n    # devolver valores al indexar nuestro iterador\\n    def __getitem__(self, ix):\\n        return self.items[ix]\\n\\nx = MiIterador(5)\\n\\nlen(x)\\n\\n5\\n\\nfor i in x:\\n    print(i)\\n\\n0\\n1\\n2\\n3\\n4\\n\\nDe esta manera podremos definir toda la l\\u00f3gica necesaria para cargar un dataset, que puede incluir cualquier n\\u00famero o tipos de transformaciones, y a la vez iterar sobre \\u00e9l como si fuese una simple lista.\\nEl operador  __call__\\nDe entre los diferentes operadores que podemos sobrecargar, el operador __call__ es muy interesante ya que nos va a permitir llamar a nuestro objeto como si de una funci\\u00f3n se tratase.\\nclass MiClase:\\n    \\n    def __init__(self, a):\\n        self.a = a\\n    \\n    def __call__(self, exp):\\n        return self.a**exp\\n\\nx = MiClase(2)\\n\\n# podemos usar nuestro objeto como una funci\\u00f3n\\nx(3)\\n\\n8\\n\\nEste patr\\u00f3n es muy utilizado en las diferentes librer\\u00edas de an\\u00e1lisis de datos, machine learning y deep learning que iremos viendo m\\u00e1s adelante.\\nHerencia\\nHablamos de herencia para referirnos al proceso de crear nuevas clases a partir de otras. Estas nuevas clases heredar\\u00e1n los m\\u00e9todos y atributos de sus clases progenitoras a la vez que nos permitir\\u00e1n a\\u00f1adir nueva funcionalidad.  \\nclass MiAlgoritmoBase:\\n    a = 1    \\n    def __call__(self):\\n        return 2*self.a\\n\\nclass MiAlgoritmo(MiAlgoritmoBase):\\n    \\n    def __init__(self, b):\\n        self.b = b\\n    \\n    def __call__(self):\\n        # el atributo `a` viene de la clase madre\\n        return 2*self.a + self.b\\n\\nx = MiAlgoritmoBase()\\n\\nx()\\n\\n2\\n\\nx = MiAlgoritmo(2)\\n\\nx()\\n\\n4\\n\\nEn el ejemplo anterior podemos ver una clase llamada MiAlgoritmoBase. Despu\\u00e9s, utilizamos esta clase para crear la nueva clase MiAlgoritmo. Como puedes ver, para crear la clase mediante herencia pasamos el nombre de la clase madre entre par\\u00e9ntesis en la definici\\u00f3n de la nueva clase. La nueva clase ahora tiene acceso a todos los m\\u00e9todos y atributos de la clase madre. Por otro lado, sobreescribimos la funci\\u00f3n __call__ por lo que al llamar a esta funci\\u00f3n en la nueva clase no llamamos a la funci\\u00f3n original de la clase madre, si no a la funci\\u00f3n de la nueva clase. \\n\\n\\u26a1 Como puedes ver el mecanismo de herencia es muy potente, permiti\\u00e9ndonos crear nuestro c\\u00f3digo poco a poco, encapsulando funcionalidad reutilizable en clases y creando nuevas clases de manera progresiva. Esta es la base de la Programaci\\u00f3n Orientada a Objetos, un paradigma de programaci\\u00f3n muy utilizado.\\n\\nHerencia m\\u00faltiple\\nPodemos crear una nueva clase a partir de varias clases progenitoras de la siguiente manera\\nclass MiAlgoritmoBase:    \\n    a = 1    \\n    def __call__(self):\\n        return 2*self.a\\n    \\nclass MiOtroAlgoritmoBase:    \\n    b = 2    \\n    def __call__(self):\\n        return -2*self.b\\n    \\nclass MiAlgoritmo(MiAlgoritmoBase, MiOtroAlgoritmoBase):\\n    \\n    # constructor\\n    def __init__(self, c):\\n        self.c = c\\n    \\n    def __call__(self):\\n        # los atributos `a` y `b` vienen de las clases progenitoras\\n        return (self.a + self.b)*self.c\\n\\nx = MiAlgoritmo(3)\\n\\nx()\\n\\n9\\n\\nEn la nueva clase tenemos acceso a todos los m\\u00e8todos y atributs de todas las clases progenitoras, a\\u00f1adiendo nuevas funciones o sobreescribiendo las ya existentes.\\nResumen\\nEn este post hemos visto como definir clases en Python, un recurso muy \\u00fatil a la hora de encapsular funcionalidad en un solo objeto con el que podemos interactuar como lo hacemos con el resto de objetos b\\u00e1sicos que Python nos ofrece. La mayor\\u00eda de algoritmos y estructuras de datos que usaremos de ahora en adelante est\\u00e1n definidos como clases de Python, con las que podremos interactuar mediante sus m\\u00e9todosy atributos. Gracias a la sobrecarga de operadores podremos utilizar los operadores m\\u00e1s comunes con nuestros propios objetos y tambi\\u00e9n nos permitir\\u00e1n crear iteradores. Por \\u00faltimo hemos hablado de herencia, un mecanismo que nos permite crear nuevas clases a partir de otras conservando los diferentes m\\u00e9todosy atributos de las clases progenitoras en la nueva clase, a\\u00f1adiendo o sobreescribiendo lo necesario para crear la nueva funcionalidad.\\n \\n\\nTWEET:"}], "model": "gpt-3.5-turbo-16k", "temperature": 0, "max_tokens": 256}' message='Post details'
https://api.openai.com:443 "POST /v1/chat/completions HTTP/1.1" 200 None
message='OpenAI API response' path=https://api.openai.com/v1/chat/completions processing_ms=1605 request_id=523e09a77b23739e76702ac42feb5c5b response_code=200
message='Request to OpenAI API' method=post path=https://api.openai.com/v1/chat/completions
api_version=None data='{"messages": [{"role": "user", "content": "Tu tarea es leer el siguiente post y generar un tweet educativo en castellano.\\nDado el siguiente post, genera un tweet de m\\u00e1ximo 200 caracteres en castellano.\\nEl tweet debe ser educativo y accesible para diferentes niveles de expertos.\\nResponde siempre en espa\\u00f1ol.\\n\\nPOST:\\n\\n\\nClases\\nEn el post anterior hablamos sobre funciones, una manera que tenemos para organizar nuestro c\\u00f3digo permitiendo su reutilizaci\\u00f3n y robustez. Una funci\\u00f3n admite una serie de argumentos que utilizar\\u00e1 para llevar a cabo una tarea determinada y, opcionalmente, devolver un resultado. En muchas ocasiones, esta aproximaci\\u00f3n es suficiente. Sin embargo, en otras ocasiones, necesitaremos un extra de funcionalidad que conseguiremos usando una clase. Como ya vimos anteriormente, en Python todo son objetos. La mayor\\u00eda de estos objetos tienen m\\u00e9todos y atributos. Los m\\u00e9todos son funciones asociadas a un objeto en particular que nos van a permitir interactuar con sus atributos, otros objetos asicioados al objeto principal. Al definir una clase seremos capaces de crear nuestros propios objetos, con sus m\\u00e9todos y atributos. Adem\\u00e1s, gracias a la herencia seremos capaces de definir nuevos objetos a partir de otros aprovechando sus m\\u00e8todos y atributos y a\\u00f1adiendo aquello que sea necesario en cada momento. As\\u00ed pues, el uso de clases extiende la idea de reutilizaci\\u00f3n y robustez de c\\u00f3digo que vimos en las funciones a\\u00f1adiendo un extra de funcionalidad.\\nDefinici\\u00f3n de Clases\\nPodemos crear una clase de la siguiente manera:\\nclass MiClase:\\n    a = \\"hola\\"\\n    \\n    def func(self):\\n        print(self.a)\\n\\nDe la misma manera que para definir una funci\\u00f3n usamos la palabra def, para definir una clase usamos la palabra class seguida por el nombre de la clase (en el ejemplo MiClase pero puedes usar el nombre que quieras). Dentro de la clase, usando indentaci\\u00f3n, definimos el atributo a y el m\\u00e9todo func. Para instanciar un objeto de nuestra clase simplemente creamos una nueva variable que llame la clase.\\nx = MiClase()\\n\\nAhora, x es un objeto del tipo MiClase y por lo tanto tiene acceso a todos sus m\\u00e9todos y atributos. Para acceder a ellos usamos la siguiente nomenclatura.\\nx.a\\n\\n\'hola\'\\n\\nx.func()\\n\\nhola\\n\\n\\n\\u26a0\\ufe0f F\\u00edjate que en la funci\\u00f3n func pasamos como primer argumento self, y para utilizar la variable a accedemos a ella como self.a. Esta es la manera que tenemos en Python para acceder a los diferentes m\\u00e9todos y atributos de un objeto desde cualquier m\\u00e9todo.\\n\\nPython es un lenguaje muy flexible y nos permite a\\u00f1adir nuevos m\\u00e9todos o atributos (o modificar los ya existentes) a cualquier objeto.\\n# modificamos un atributo\\n\\nx.a = \\"hello\\"\\nx.a\\n\\n\'hello\'\\n\\n# a\\u00f1adimos un nuevo atributo\\n\\nx.b = \\"hola\\"\\nx.b\\n\\n\'hola\'\\n\\nEs importante remarcar que el a\\u00f1adir nuevos m\\u00e9todos o atributos a un objeto no los a\\u00f1adir\\u00e1 en la definici\\u00f3n de la clase original.\\ny = MiClase()\\n\\n# el atributo `b` no existe\\ny.b\\n\\n---------------------------------------------------------------------------\\n\\nAttributeError                            Traceback (most recent call last)\\n\\n<ipython-input-7-f64f348aaab1> in <module>\\n      2 \\n      3 # el atributo `b` no existe\\n----> 4 y.b\\n\\n\\nAttributeError: \'MiClase\' object has no attribute \'b\'\\n\\nEl constructor\\nCada vez que creemos un nuevo objeto de nuestra clase tendremos el mismo valor para el atributo a. Sin embargo, es muy com\\u00fan utilizar una misma clase con diferentes valores para el mismo atributo. Para ello podemos pasarle los valores con los que queremos inicializar nuestro objeto a trav\\u00e9s del constructor.\\nclass MiClase:\\n    \\n    # Constructor\\n    def __init__(self, a):\\n        self.a = a\\n    \\n    def func(self):\\n        print(self.a)\\n\\nx = MiClase(\\"hola\\")\\ny = MiClase(\\"hello\\")\\n\\nx.func()\\n\\nhola\\n\\ny.func()\\n\\nhello\\n\\n\\n\\u26a0\\ufe0f El constructor de una clase siempre se define mediante la funci\\u00f3n __init__(self, argumentos).\\n\\nSobrecarga de operadores\\nImagina que queremos sumar dos n\\u00fameros. En Python es tan f\\u00e1cil como.\\nx = 1\\ny = 2\\n\\nx + y\\n\\n3\\n\\n\\u00bfPodemos hacer lo mismo con nuestra clase?\\nx = MiClase(1)\\ny = MiClase(2)\\n\\nx + y\\n\\n---------------------------------------------------------------------------\\n\\nTypeError                                 Traceback (most recent call last)\\n\\n<ipython-input-13-9c40486136a8> in <module>\\n      2 y = MiClase(2)\\n      3 \\n----> 4 x + y\\n\\n\\nTypeError: unsupported operand type(s) for +: \'MiClase\' and \'MiClase\'\\n\\nLa respuesta es no, y el motivo es que nuestra clase no tiene definido el m\\u00e9todo suma. Podemos definirlo de la siguiente manera\\nclass MiClase:\\n    \\n    # Constructor\\n    def __init__(self, a):\\n        self.a = a\\n    \\n    # sobrecarga suma\\n    def __add__(self, other):\\n        return self.a + other.a\\n    \\n    def func(self):\\n        print(self.a)\\n\\nx = MiClase(1)\\ny = MiClase(2)\\n\\nx + y\\n\\n3\\n\\nAl definir el m\\u00e9todo __add__ ahora nuestra clase soporta el operador suma. Esto se conoce como sobrecarga de operadores y es especialmente \\u00fatil cuando hacemos an\\u00e1lisis de datos, ya que podremos trabajar con nuestras clases como si lo hici\\u00e9semos con cualquier otro objeto de Python de manera transparente. Podemos sobrecargar pr\\u00e1cticamente todos los operadores, aqu\\u00ed puedes encontrar una lista.\\nclass MiClase:\\n    \\n    # Constructor\\n    def __init__(self, a):\\n        self.a = a\\n    \\n    # sobrecarga suma\\n    def __add__(self, other):\\n        return self.a + other.a\\n    \\n    # sobrecarga string (controlamos lo que se ve al hacer un `print` de nuestro objeto)\\n    def __str__(self):\\n        return f\'El valor de `a` es {self.a}\' \\n    \\n    def func(self):\\n        print(self.a)\\n\\nx = MiClase(1.56)\\n\\nprint(x)\\n\\nEl valor de `a` es 1.56\\n\\nPodemos utilizar esta sobrecarga de operadores para definir clases que puedan ser iterables (de forma an\\u00e1loga a los generadores que vimos en el post anterior).\\nclass MiIterador:\\n    \\n    # Constructor\\n    def __init__(self, n):\\n        self.items = [i for i in range(n)]\\n    \\n    # longitud del iterador\\n    def __len__(self):\\n        return len(self.items)\\n    \\n    # devolver valores al indexar nuestro iterador\\n    def __getitem__(self, ix):\\n        return self.items[ix]\\n\\nx = MiIterador(5)\\n\\nlen(x)\\n\\n5\\n\\nfor i in x:\\n    print(i)\\n\\n0\\n1\\n2\\n3\\n4\\n\\nDe esta manera podremos definir toda la l\\u00f3gica necesaria para cargar un dataset, que puede incluir cualquier n\\u00famero o tipos de transformaciones, y a la vez iterar sobre \\u00e9l como si fuese una simple lista.\\nEl operador  __call__\\nDe entre los diferentes operadores que podemos sobrecargar, el operador __call__ es muy interesante ya que nos va a permitir llamar a nuestro objeto como si de una funci\\u00f3n se tratase.\\nclass MiClase:\\n    \\n    def __init__(self, a):\\n        self.a = a\\n    \\n    def __call__(self, exp):\\n        return self.a**exp\\n\\nx = MiClase(2)\\n\\n# podemos usar nuestro objeto como una funci\\u00f3n\\nx(3)\\n\\n8\\n\\nEste patr\\u00f3n es muy utilizado en las diferentes librer\\u00edas de an\\u00e1lisis de datos, machine learning y deep learning que iremos viendo m\\u00e1s adelante.\\nHerencia\\nHablamos de herencia para referirnos al proceso de crear nuevas clases a partir de otras. Estas nuevas clases heredar\\u00e1n los m\\u00e9todos y atributos de sus clases progenitoras a la vez que nos permitir\\u00e1n a\\u00f1adir nueva funcionalidad.  \\nclass MiAlgoritmoBase:\\n    a = 1    \\n    def __call__(self):\\n        return 2*self.a\\n\\nclass MiAlgoritmo(MiAlgoritmoBase):\\n    \\n    def __init__(self, b):\\n        self.b = b\\n    \\n    def __call__(self):\\n        # el atributo `a` viene de la clase madre\\n        return 2*self.a + self.b\\n\\nx = MiAlgoritmoBase()\\n\\nx()\\n\\n2\\n\\nx = MiAlgoritmo(2)\\n\\nx()\\n\\n4\\n\\nEn el ejemplo anterior podemos ver una clase llamada MiAlgoritmoBase. Despu\\u00e9s, utilizamos esta clase para crear la nueva clase MiAlgoritmo. Como puedes ver, para crear la clase mediante herencia pasamos el nombre de la clase madre entre par\\u00e9ntesis en la definici\\u00f3n de la nueva clase. La nueva clase ahora tiene acceso a todos los m\\u00e9todos y atributos de la clase madre. Por otro lado, sobreescribimos la funci\\u00f3n __call__ por lo que al llamar a esta funci\\u00f3n en la nueva clase no llamamos a la funci\\u00f3n original de la clase madre, si no a la funci\\u00f3n de la nueva clase. \\n\\n\\u26a1 Como puedes ver el mecanismo de herencia es muy potente, permiti\\u00e9ndonos crear nuestro c\\u00f3digo poco a poco, encapsulando funcionalidad reutilizable en clases y creando nuevas clases de manera progresiva. Esta es la base de la Programaci\\u00f3n Orientada a Objetos, un paradigma de programaci\\u00f3n muy utilizado.\\n\\nHerencia m\\u00faltiple\\nPodemos crear una nueva clase a partir de varias clases progenitoras de la siguiente manera\\nclass MiAlgoritmoBase:    \\n    a = 1    \\n    def __call__(self):\\n        return 2*self.a\\n    \\nclass MiOtroAlgoritmoBase:    \\n    b = 2    \\n    def __call__(self):\\n        return -2*self.b\\n    \\nclass MiAlgoritmo(MiAlgoritmoBase, MiOtroAlgoritmoBase):\\n    \\n    # constructor\\n    def __init__(self, c):\\n        self.c = c\\n    \\n    def __call__(self):\\n        # los atributos `a` y `b` vienen de las clases progenitoras\\n        return (self.a + self.b)*self.c\\n\\nx = MiAlgoritmo(3)\\n\\nx()\\n\\n9\\n\\nEn la nueva clase tenemos acceso a todos los m\\u00e8todos y atributs de todas las clases progenitoras, a\\u00f1adiendo nuevas funciones o sobreescribiendo las ya existentes.\\nResumen\\nEn este post hemos visto como definir clases en Python, un recurso muy \\u00fatil a la hora de encapsular funcionalidad en un solo objeto con el que podemos interactuar como lo hacemos con el resto de objetos b\\u00e1sicos que Python nos ofrece. La mayor\\u00eda de algoritmos y estructuras de datos que usaremos de ahora en adelante est\\u00e1n definidos como clases de Python, con las que podremos interactuar mediante sus m\\u00e9todosy atributos. Gracias a la sobrecarga de operadores podremos utilizar los operadores m\\u00e1s comunes con nuestros propios objetos y tambi\\u00e9n nos permitir\\u00e1n crear iteradores. Por \\u00faltimo hemos hablado de herencia, un mecanismo que nos permite crear nuevas clases a partir de otras conservando los diferentes m\\u00e9todosy atributos de las clases progenitoras en la nueva clase, a\\u00f1adiendo o sobreescribiendo lo necesario para crear la nueva funcionalidad.\\n \\n\\nTWEET:"}], "model": "gpt-3.5-turbo-16k", "temperature": 0, "max_tokens": 256}' message='Post details'
https://api.openai.com:443 "POST /v1/chat/completions HTTP/1.1" 200 None
message='OpenAI API response' path=https://api.openai.com/v1/chat/completions processing_ms=1133 request_id=5ca718f367d252b3d86c491446c0bfdd response_code=200
message='Request to OpenAI API' method=post path=https://api.openai.com/v1/chat/completions
api_version=None data='{"messages": [{"role": "user", "content": "Tu tarea es leer el siguiente post y generar un tweet educativo en castellano.\\nDado el siguiente post, genera un tweet de m\\u00e1ximo 200 caracteres en castellano.\\nEl tweet debe ser educativo y accesible para diferentes niveles de expertos.\\nResponde siempre en espa\\u00f1ol.\\n\\nPOST:\\n\\n\\nClases\\nEn el post anterior hablamos sobre funciones, una manera que tenemos para organizar nuestro c\\u00f3digo permitiendo su reutilizaci\\u00f3n y robustez. Una funci\\u00f3n admite una serie de argumentos que utilizar\\u00e1 para llevar a cabo una tarea determinada y, opcionalmente, devolver un resultado. En muchas ocasiones, esta aproximaci\\u00f3n es suficiente. Sin embargo, en otras ocasiones, necesitaremos un extra de funcionalidad que conseguiremos usando una clase. Como ya vimos anteriormente, en Python todo son objetos. La mayor\\u00eda de estos objetos tienen m\\u00e9todos y atributos. Los m\\u00e9todos son funciones asociadas a un objeto en particular que nos van a permitir interactuar con sus atributos, otros objetos asicioados al objeto principal. Al definir una clase seremos capaces de crear nuestros propios objetos, con sus m\\u00e9todos y atributos. Adem\\u00e1s, gracias a la herencia seremos capaces de definir nuevos objetos a partir de otros aprovechando sus m\\u00e8todos y atributos y a\\u00f1adiendo aquello que sea necesario en cada momento. As\\u00ed pues, el uso de clases extiende la idea de reutilizaci\\u00f3n y robustez de c\\u00f3digo que vimos en las funciones a\\u00f1adiendo un extra de funcionalidad.\\nDefinici\\u00f3n de Clases\\nPodemos crear una clase de la siguiente manera:\\nclass MiClase:\\n    a = \\"hola\\"\\n    \\n    def func(self):\\n        print(self.a)\\n\\nDe la misma manera que para definir una funci\\u00f3n usamos la palabra def, para definir una clase usamos la palabra class seguida por el nombre de la clase (en el ejemplo MiClase pero puedes usar el nombre que quieras). Dentro de la clase, usando indentaci\\u00f3n, definimos el atributo a y el m\\u00e9todo func. Para instanciar un objeto de nuestra clase simplemente creamos una nueva variable que llame la clase.\\nx = MiClase()\\n\\nAhora, x es un objeto del tipo MiClase y por lo tanto tiene acceso a todos sus m\\u00e9todos y atributos. Para acceder a ellos usamos la siguiente nomenclatura.\\nx.a\\n\\n\'hola\'\\n\\nx.func()\\n\\nhola\\n\\n\\n\\u26a0\\ufe0f F\\u00edjate que en la funci\\u00f3n func pasamos como primer argumento self, y para utilizar la variable a accedemos a ella como self.a. Esta es la manera que tenemos en Python para acceder a los diferentes m\\u00e9todos y atributos de un objeto desde cualquier m\\u00e9todo.\\n\\nPython es un lenguaje muy flexible y nos permite a\\u00f1adir nuevos m\\u00e9todos o atributos (o modificar los ya existentes) a cualquier objeto.\\n# modificamos un atributo\\n\\nx.a = \\"hello\\"\\nx.a\\n\\n\'hello\'\\n\\n# a\\u00f1adimos un nuevo atributo\\n\\nx.b = \\"hola\\"\\nx.b\\n\\n\'hola\'\\n\\nEs importante remarcar que el a\\u00f1adir nuevos m\\u00e9todos o atributos a un objeto no los a\\u00f1adir\\u00e1 en la definici\\u00f3n de la clase original.\\ny = MiClase()\\n\\n# el atributo `b` no existe\\ny.b\\n\\n---------------------------------------------------------------------------\\n\\nAttributeError                            Traceback (most recent call last)\\n\\n<ipython-input-7-f64f348aaab1> in <module>\\n      2 \\n      3 # el atributo `b` no existe\\n----> 4 y.b\\n\\n\\nAttributeError: \'MiClase\' object has no attribute \'b\'\\n\\nEl constructor\\nCada vez que creemos un nuevo objeto de nuestra clase tendremos el mismo valor para el atributo a. Sin embargo, es muy com\\u00fan utilizar una misma clase con diferentes valores para el mismo atributo. Para ello podemos pasarle los valores con los que queremos inicializar nuestro objeto a trav\\u00e9s del constructor.\\nclass MiClase:\\n    \\n    # Constructor\\n    def __init__(self, a):\\n        self.a = a\\n    \\n    def func(self):\\n        print(self.a)\\n\\nx = MiClase(\\"hola\\")\\ny = MiClase(\\"hello\\")\\n\\nx.func()\\n\\nhola\\n\\ny.func()\\n\\nhello\\n\\n\\n\\u26a0\\ufe0f El constructor de una clase siempre se define mediante la funci\\u00f3n __init__(self, argumentos).\\n\\nSobrecarga de operadores\\nImagina que queremos sumar dos n\\u00fameros. En Python es tan f\\u00e1cil como.\\nx = 1\\ny = 2\\n\\nx + y\\n\\n3\\n\\n\\u00bfPodemos hacer lo mismo con nuestra clase?\\nx = MiClase(1)\\ny = MiClase(2)\\n\\nx + y\\n\\n---------------------------------------------------------------------------\\n\\nTypeError                                 Traceback (most recent call last)\\n\\n<ipython-input-13-9c40486136a8> in <module>\\n      2 y = MiClase(2)\\n      3 \\n----> 4 x + y\\n\\n\\nTypeError: unsupported operand type(s) for +: \'MiClase\' and \'MiClase\'\\n\\nLa respuesta es no, y el motivo es que nuestra clase no tiene definido el m\\u00e9todo suma. Podemos definirlo de la siguiente manera\\nclass MiClase:\\n    \\n    # Constructor\\n    def __init__(self, a):\\n        self.a = a\\n    \\n    # sobrecarga suma\\n    def __add__(self, other):\\n        return self.a + other.a\\n    \\n    def func(self):\\n        print(self.a)\\n\\nx = MiClase(1)\\ny = MiClase(2)\\n\\nx + y\\n\\n3\\n\\nAl definir el m\\u00e9todo __add__ ahora nuestra clase soporta el operador suma. Esto se conoce como sobrecarga de operadores y es especialmente \\u00fatil cuando hacemos an\\u00e1lisis de datos, ya que podremos trabajar con nuestras clases como si lo hici\\u00e9semos con cualquier otro objeto de Python de manera transparente. Podemos sobrecargar pr\\u00e1cticamente todos los operadores, aqu\\u00ed puedes encontrar una lista.\\nclass MiClase:\\n    \\n    # Constructor\\n    def __init__(self, a):\\n        self.a = a\\n    \\n    # sobrecarga suma\\n    def __add__(self, other):\\n        return self.a + other.a\\n    \\n    # sobrecarga string (controlamos lo que se ve al hacer un `print` de nuestro objeto)\\n    def __str__(self):\\n        return f\'El valor de `a` es {self.a}\' \\n    \\n    def func(self):\\n        print(self.a)\\n\\nx = MiClase(1.56)\\n\\nprint(x)\\n\\nEl valor de `a` es 1.56\\n\\nPodemos utilizar esta sobrecarga de operadores para definir clases que puedan ser iterables (de forma an\\u00e1loga a los generadores que vimos en el post anterior).\\nclass MiIterador:\\n    \\n    # Constructor\\n    def __init__(self, n):\\n        self.items = [i for i in range(n)]\\n    \\n    # longitud del iterador\\n    def __len__(self):\\n        return len(self.items)\\n    \\n    # devolver valores al indexar nuestro iterador\\n    def __getitem__(self, ix):\\n        return self.items[ix]\\n\\nx = MiIterador(5)\\n\\nlen(x)\\n\\n5\\n\\nfor i in x:\\n    print(i)\\n\\n0\\n1\\n2\\n3\\n4\\n\\nDe esta manera podremos definir toda la l\\u00f3gica necesaria para cargar un dataset, que puede incluir cualquier n\\u00famero o tipos de transformaciones, y a la vez iterar sobre \\u00e9l como si fuese una simple lista.\\nEl operador  __call__\\nDe entre los diferentes operadores que podemos sobrecargar, el operador __call__ es muy interesante ya que nos va a permitir llamar a nuestro objeto como si de una funci\\u00f3n se tratase.\\nclass MiClase:\\n    \\n    def __init__(self, a):\\n        self.a = a\\n    \\n    def __call__(self, exp):\\n        return self.a**exp\\n\\nx = MiClase(2)\\n\\n# podemos usar nuestro objeto como una funci\\u00f3n\\nx(3)\\n\\n8\\n\\nEste patr\\u00f3n es muy utilizado en las diferentes librer\\u00edas de an\\u00e1lisis de datos, machine learning y deep learning que iremos viendo m\\u00e1s adelante.\\nHerencia\\nHablamos de herencia para referirnos al proceso de crear nuevas clases a partir de otras. Estas nuevas clases heredar\\u00e1n los m\\u00e9todos y atributos de sus clases progenitoras a la vez que nos permitir\\u00e1n a\\u00f1adir nueva funcionalidad.  \\nclass MiAlgoritmoBase:\\n    a = 1    \\n    def __call__(self):\\n        return 2*self.a\\n\\nclass MiAlgoritmo(MiAlgoritmoBase):\\n    \\n    def __init__(self, b):\\n        self.b = b\\n    \\n    def __call__(self):\\n        # el atributo `a` viene de la clase madre\\n        return 2*self.a + self.b\\n\\nx = MiAlgoritmoBase()\\n\\nx()\\n\\n2\\n\\nx = MiAlgoritmo(2)\\n\\nx()\\n\\n4\\n\\nEn el ejemplo anterior podemos ver una clase llamada MiAlgoritmoBase. Despu\\u00e9s, utilizamos esta clase para crear la nueva clase MiAlgoritmo. Como puedes ver, para crear la clase mediante herencia pasamos el nombre de la clase madre entre par\\u00e9ntesis en la definici\\u00f3n de la nueva clase. La nueva clase ahora tiene acceso a todos los m\\u00e9todos y atributos de la clase madre. Por otro lado, sobreescribimos la funci\\u00f3n __call__ por lo que al llamar a esta funci\\u00f3n en la nueva clase no llamamos a la funci\\u00f3n original de la clase madre, si no a la funci\\u00f3n de la nueva clase. \\n\\n\\u26a1 Como puedes ver el mecanismo de herencia es muy potente, permiti\\u00e9ndonos crear nuestro c\\u00f3digo poco a poco, encapsulando funcionalidad reutilizable en clases y creando nuevas clases de manera progresiva. Esta es la base de la Programaci\\u00f3n Orientada a Objetos, un paradigma de programaci\\u00f3n muy utilizado.\\n\\nHerencia m\\u00faltiple\\nPodemos crear una nueva clase a partir de varias clases progenitoras de la siguiente manera\\nclass MiAlgoritmoBase:    \\n    a = 1    \\n    def __call__(self):\\n        return 2*self.a\\n    \\nclass MiOtroAlgoritmoBase:    \\n    b = 2    \\n    def __call__(self):\\n        return -2*self.b\\n    \\nclass MiAlgoritmo(MiAlgoritmoBase, MiOtroAlgoritmoBase):\\n    \\n    # constructor\\n    def __init__(self, c):\\n        self.c = c\\n    \\n    def __call__(self):\\n        # los atributos `a` y `b` vienen de las clases progenitoras\\n        return (self.a + self.b)*self.c\\n\\nx = MiAlgoritmo(3)\\n\\nx()\\n\\n9\\n\\nEn la nueva clase tenemos acceso a todos los m\\u00e8todos y atributs de todas las clases progenitoras, a\\u00f1adiendo nuevas funciones o sobreescribiendo las ya existentes.\\nResumen\\nEn este post hemos visto como definir clases en Python, un recurso muy \\u00fatil a la hora de encapsular funcionalidad en un solo objeto con el que podemos interactuar como lo hacemos con el resto de objetos b\\u00e1sicos que Python nos ofrece. La mayor\\u00eda de algoritmos y estructuras de datos que usaremos de ahora en adelante est\\u00e1n definidos como clases de Python, con las que podremos interactuar mediante sus m\\u00e9todosy atributos. Gracias a la sobrecarga de operadores podremos utilizar los operadores m\\u00e1s comunes con nuestros propios objetos y tambi\\u00e9n nos permitir\\u00e1n crear iteradores. Por \\u00faltimo hemos hablado de herencia, un mecanismo que nos permite crear nuevas clases a partir de otras conservando los diferentes m\\u00e9todosy atributos de las clases progenitoras en la nueva clase, a\\u00f1adiendo o sobreescribiendo lo necesario para crear la nueva funcionalidad.\\n \\n\\nTWEET:"}], "model": "gpt-3.5-turbo-16k", "temperature": 0, "max_tokens": 256}' message='Post details'
https://api.openai.com:443 "POST /v1/chat/completions HTTP/1.1" 200 None
message='OpenAI API response' path=https://api.openai.com/v1/chat/completions processing_ms=1397 request_id=cffad99d0d45dddd36be8fb74a0fa433 response_code=200
